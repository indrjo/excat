
\chapter{Preliminari}



\section{Kernel e cokernel}

Noi lavoreremo con categorie in cui sono presenti oggetti che sono sia
terminali che iniziali. Oggetti di questo tipo sono detti {\em oggetti
  zero}. Non si tratta di categorie come \(\Set\), \(\Top\) e \(\Ring\),
ma è il caso di \(\Grp\) e \(\Modu_R\), con \(R\) anello.

\begin{definition}
  Sia \(\cat C\) una categoria con {\em oggetto zero} che indichiamo con
  \(0\). Per \(A, B \in \obj{\cat C}\), il {\em morfismo nullo} o {\em
    zero} da \(A\) a \(B\) è la composizione dei morfismi
  \[
    \begin{tikzcd}[column sep=small]
      A \ar["{\exists!}", r] & 0 \ar["{\exists!}", r] & B
    \end{tikzcd}
  \]
  Scriveremo questo morfismo come \(0_A^B\) oppure, se dal contesto è
  chiaro, semplicemente \(0\).
\end{definition}

\begin{example}
  In casi come \(\Grp\) e \(\Modu_R\), il morfismo nullo è quello che
  manda tutti gli elementi del dominio nell'identità. % Anche \(\Ring\)
  % possiede omomorfismi come questi; tuttavia in \(\Ring\) l'oggetto
  % iniziale è \(\mathbb{Z}\) che non è terminale mentre i morfismi zero sono
  % definiti attraverso oggetti zero. {\color{red} [I morfismi di anelli
  %   preservano l'identità\dots{} Rivedere.]}
\end{example}

Comporre con un morfismo nullo dà un morfismo nullo. Più precisamente:

\begin{proposition}\label{lemma:CompCon0}
  Sia \(\cat C\) una categoria con {\em oggetto zero} \(0\), e
  \(A, B, C \in \obj{\cat C}\). Allora per ogni \(f : B \to C\) di
  \(\cat C\) si ha
  \[
    f 0_A^B = 0_A^C
  \]
  e per ogni \(g : C \to A\) di \(\cat C\) si ha
  \[
    0_A^B g = 0_C^B .
  \]
\end{proposition}

\begin{proof}
  Proviamo solo una delle due uguaglianze perché l'altra è
  simile. Consideriamo i morfismi
  \[
    \begin{tikzcd}[column sep=small]
      A \ar["{\exists!}", r] & 0 \ar["{\exists!}", r] & B \ar["f", r] & C
    \end{tikzcd}
  \]
  Poiché \(0\) è iniziale, la composizione delle ultime due frecce è
  l'unica che può esserci. Quindi \(f 0_A^B\) è la composizione della
  freccia \(A \to 0\) con la freccia \(0 \to C\), ed abbiamo concluso.
\end{proof}

\begin{definition}
  In una categoria \(\cat C\) con oggetto zero \(0\), il {\em kernel} di
  \(f : A \to B\) è uno qualsiasi degli equalizzatori di
  \[
    \begin{tikzcd}
      A \ar["f", shift left, r] \ar["{0_A^B}", shift right, swap, r] & B
    \end{tikzcd}
  \]
  Dualmente, il {\em cokernel} di \(f : A \to B\) è uno qualsiasi dei
  coequalizzatori della stessa coppia di morfismi.
\end{definition}

\begin{remark}
  In generale gli equalizzatori sono monomorfismi e i
  coequalizzatori sono epimorfismi.
\end{remark}

\begin{example}[Kernel di omomorfismi di
  moduli]\label{example:KernelInModR}
  In Algebra, si parla di {\em kernel} di morfismi in vari ambiti. Per
  esempio, se \(M\) e \(N\) sono due moduli su un fissato anello \(R\) e
  \(f : M \to N\) è un omomorfismo, allora
  \[
    \ker f := \set{x \in M \mid f(x) = 0_N}
  \]
  è un sottomodulo di \(M\). Per entrare nel linguaggio della {\sc
    Teoria delle Categorie}, l'omomorfismo inclusione
  \(i : \ker f \hookrightarrow M\) è un equalizzatore della coppia di omomorfismi
  \[
    \begin{tikzcd}
      M \ar["f", shift left, r] \ar["{0_M^N}", shift right, swap, r] & N
    \end{tikzcd}
  \]
\end{example}

\begin{example}[Cokernel di omomorfismi di
  moduli]\label{example:CokernelInModR}
  Se \(M\) e \(N\) sono due moduli su un fissato anello \(R\) e
  \(f : M \to N\) è un omomorfismo, allora
  \[
    \coker f := \frac{N}{\im f}
  \]
  è un sottomodulo di \(M\) chiamato {\em cokernel} di \(f\). Questa
  nozione è il duale di kernel, nel senso che l'omomorfismo di
  proiezione canonica al quoziente \(\pi_N : N \to \coker f\) è un
  coequalizzatore della coppia di omomorfismi
  \[
    \begin{tikzcd}
      M \ar["f", shift left, r] \ar["{0_M^N}", shift right, swap, r] & N
    \end{tikzcd}
  \]
\end{example}

\begin{recall}[La categoria \(\Ban\)]
  Uno {\em spazio di Banach} è uno spazio normato
  \((X, \left\lVert \cdot \right\rVert)\) su un campo \(k\) (che spesso è
  \(\mathbb{R}\) oppure \(\mathbb{C}\)) che è uno spazio metrico completo
  rispetto alla distanza
  \[
    d : X \times X \to \mathbb{R} \,, \ d(x, y) := \left\lVert x-y \right\rVert .
  \]
  Un'applicazione lineare tra spazi normati
  \(f : (X, \left\lVert \cdot \right\rVert_X) \to (Y, \left\lVert \cdot
  \right\rVert_Y)\) è detta {\em limitata} qualora esiste \(M > 0\) per
  cui
  \[
    \left\lVert f x \right\rVert \le M \left\lVert x \right\rVert_X
    \quad\text{per ogni } x \in X .
  \]
  Indichiamo con \(\Ban\) la categoria degli spazi di Banach e delle
  applicazioni lineari limitate. Poiché esiste un funtore dimenticante
  fedele \(U : \Ban \to \Vect_k\), anche \(\Ban\) ha oggetto zero, lo
  spazio vettoriale banale.
\end{recall}

\begin{example}
  Anche in \(\Ban\), come in \(\Modu_R\), il kernel di un'applicazione
  lineare limitata con l'inclusione forma un kernel nel senso della
  nostra definizione.
\end{example}

\begin{recall}
  Dato uno spazio di Banach \((X, \left\lVert \cdot \right\rVert)\) e un suo
  sottospazio chiuso \(M\), allora lo spazio vettoriale quoziente
  \(X/M\) diventa uno spazio di Banach se considerato insieme alla norma
  indotta sul quoziente così definita:
  \[
    \lsem x + M \rsem := \inf_{m \in M} \left\lVert x+m \right\rVert .
  \]
  In generale, non è detto che il passaggio al quoziente per un
  sottospazio non chiuso induca una norma e dia origine ad uno spazio di
  Banach. Se si vuole uno spazio di Banach, quindi o ci si assicura che
  il sottospazio in questione è chiuso oppure si prende la sua chiusura
  (topologica).
\end{recall}

\begin{example}
  Altra storia invece per i cokernel in \(\Ban\). Sia
  \(f : (X, \left\lVert \cdot \right\rVert_X) \to (Y, \left\lVert \cdot
  \right\rVert_Y)\) un'applicazione lineare limitata. Allora il cokernel
  di \(f\) è la proiezione canonica al quoziente
  \(Y \to {Y}{/}{\bar{\im f}}\).
\end{example}

\begin{remark}
  In Algebra, kernel e cokernel sono degli oggetti, mentre tecnicamente
  come sono definiti qui sono dei morfismi.
\end{remark}



\section{Categorie preadditive}

\begin{definition}
  Una {\em categoria preadditiva} è una categoria \(\cat C\) in cui:
  \begin{enumerate}[leftmargin=*]
  \item Per ogni \(A, B \in \obj{\cat C}\) la classe \(\cat C(A, B)\) è
    dotata di un'operazione interna
    \[
      +_{A,B} : \cat C (A, B) \times \cat C (A, B) \to \cat C (A, B)
    \]
    e ha un elemento \(0_A^B : A \to B\) che lo rendono un gruppo
    abeliano.
  \item Per ogni \(A, B, C, D \in \obj{\cat C}\) e \(f : A \to B\) di
    \(\cat C\), le funzioni
    \begin{align*}
      & f_\ast := \cat C(C, f) : \cat C(C, A) \to \cat C(C, B) \\
      & f^\ast := \cat C(f, D) : \cat C(B, D) \to \cat C(A, D)
    \end{align*}
    sono omomorfismi di gruppi abeliani.
  \end{enumerate}
\end{definition}

\begin{recall}
  Ricordiamo che
  \begin{align*}
    & f_\ast(g) := f g \\
    & f^\ast(h) := h f
  \end{align*}
\end{recall}

Noi scriveremo semplicemente \(+\) senza pedici, perché in genere è
chiaro in base a quali frecce stiamo sommando.

Inoltre, come nei primi teoremi di Algebra, il morfismo zero è l'unico
elemento neutro e per ogni \(f : A \to B\) è unico l'opposto. In
coerenza con la notazione additiva, indichiamo con \(- f : A \to B\)
l'opposto di \(f : A \to B\).

\begin{example}
  La categoria dei moduli su un fissato anello \(R\) è un semplice
  esempio di categoria preadditiva. Infatti, gli insiemi
  \(\Modu_R (M, N)\), con \(M\) e \(N\) moduli, sono gruppi abeliani con
  l'operazione \(+\) in cui \(f + g\) è l'applicazione lineare
  \(x \mapsto f(x) + g(x)\). Per questioni di linearità, segue anche che le
  pre- e post-composizioni sono omomorfismi di gruppi abeliani.
\end{example}

\begin{example}
  Anche \(\Ban\) è una categoria preadditiva con le operazioni di somma
  di morfismi definite come in \(\Modu_R\): infatti se \(f, g
  : E \to F\) sono applicazioni lineari limitate, allora anche \(f + g\)
  lo è.
\end{example}

Un'altra osservazione da fare è questa. Il simbolo \(0_A^B\) in una
categoria \(\cat C\) con oggetto zero indica il morfismo zero
\(A \to B\). Se \(\cat C\) è preaddittiva, non sono notazioni in
conflitto?  No.

\begin{proposition}
  In una categoria preadditiva \(\cat C\) con oggetto zero \(0\), il
  morfismo nullo è elemento neutro.
\end{proposition}

\begin{proof}
  Poiché \(0\) è iniziale, \(\cat C(0, B)\) è banale e in particolare
  \(0_0^B\) è elemento neutro. L'omomorfismo
  \[
    \left(0_A^0\right)^\ast : \cat C(0, B) \to \cat C(A, B)
  \]
  manda l'elemento neutro del dominio in quello del codominio, che è
  \[
    \left(0_A^0\right)^\ast\left(0_0^B\right) = 0_0^B 0_A^0 = 0_A^B
    . \qedhere
  \]
\end{proof}

\begin{remark}
  A tal proposito è utile osservare che se \(\cat C\) è una categoria
  preadditiva, anche il suo duale \(\opcat C\) lo è. La conseguenza più
  pratica per noi è che dimezza le dimostrazioni: una volta dimostrato
  un enunciato, quello duale è automatico.
\end{remark}

Un mantra dell'Algebra è che un omomorfismo è iniettivo se e solo se è
il suo kernel è banale. Questo continua a valere, con qualche
precauzione, anche nelle categorie preadditive.

\begin{proposition}\label{proposition:MonoIffKerIsTrivial}
  Sia \(\cat C\) una categoria preadditiva con oggetto zero
  \(0\). Allora \(f : A \to B\) è monomorfismo se e solo se
  \(\begin{tikzcd}[column sep=small, cramped] 0 \ar["{\exists!}", r] &
    A \end{tikzcd}\) è kernel di \(f\).
\end{proposition}

\begin{proof}
  (\Rightarrow) Questa implicazione è valida in qualsiasi categoria con
  oggetto zero. Sia
  \[
    \begin{tikzcd}
      E \ar["{i}", r] & A \ar["{f}", r, shift left] \ar["{0_A^B}", r,
      shift right, swap] & B
    \end{tikzcd}
  \]
  commutativo. Allora
  \[
    f i = 0_A^B i = 0_E^B = f 0_E^A
  \]
  Essendo \(f\) un monomorfismo, allora \(i = 0_E^A\). Pertanto \(i\)
  fattorizza attraverso \(0 \to A\) in un unico modo (\(0\) è terminale):
  \[
    \begin{tikzcd}
      0 \ar["{\exists!}", r] & A \\
      E \ar["{\exists!}", u] \ar["{i = 0_E^A}", ur, swap]
    \end{tikzcd}
  \]
  (\Leftarrow) Siano \(h, k : A' \to A\) tali che \(f h = f k\). Questo
  vuol dire che \(f (h-k) = 0_E^B = 0_A^B (h-k)\). Per la definizione di
  kernel, esiste un e un solo morfismo \(j : A' \to 0\) tale che
  \(h-k = 0_0^A j = 0_{A'}^A\). In conclusione, \(h = k\).
\end{proof}


\section{Limiti e colimiti}

Ora parleremo di alcune peculiarità dei limiti e dei colimiti in
categorie preadditive.


\subsection{Oggetti iniziali e terminali}

\begin{proposition}
  In un categoria preadditiva \(\cat C\) gli oggetti terminali sono
  iniziali e viceversa.
\end{proposition}

Quindi in una categoria preadditiva gli oggetti terminali e iniziali
sono oggetti zero.

\begin{proof}
  Sia \(T\) un oggetto terminale di \(\cat C\). Se riusciamo a mostrare
  che \(\cat C(T, A)\) è un gruppo banale per ogni oggetto \(A\) di
  \(\cat C\), allora possiamo concludere.\newline Prendiamo un
  \(f : T \to A\) qualsiasi in \(\cat C\) e guardiamo l'omomorfismo di
  gruppi
  \[
    f_\ast = \cat C(T, f) : \cat C(T, T) \to \cat C(T, A) .
  \]
  Il dominio è un gruppo banale perché \(T\) è terminale; in
  particolare, \(\id_T = 0_T^T\). Inoltre, trattandosi di omomorfismo,
  \[
    \underbrace{f_\ast \left(\id_T\right)}_{= f} = f 0_T^T = 0_T^A
    . \qedhere
  \]
\end{proof}


\subsection{Prodotti, coprodotti e biprodotti}

\begin{notation}
  A proposito di notazioni, seguiamo~\cite{leinster:categories}
  e~\cite{riehl:categories}. Più precisamente, preso un prodotto
  \[
    \begin{tikzcd}[column sep=small]
      A & A \times B \ar["{p_A}", l, swap] \ar["{p_B}", r] & B
    \end{tikzcd}
  \]
  il morfismo \(C \to A \times B\) che fa commutare il diagramma
  \[
    \begin{tikzcd}
      & C \ar["{f}", dl, swap] \ar[d] \ar["{g}", dr] \\
      A & A \times B \ar["{p_A}", l] \ar["{p_B}", r, swap] & B
    \end{tikzcd}
  \]
  è indicato con \((f, g)\); invece, dato un coprodotto
  \[
    \begin{tikzcd}[column sep=small]
      A \ar["{i_A}", r] & A + B & B \ar["{i_B}", l, swap]
    \end{tikzcd}
  \]
  il morfismo \(A+B \to C\) che rende commutativo
  \[
    \begin{tikzcd}
      & A \\
      A \ar["{i_A}", r, swap] \ar["{f}", ur] & A + B \ar[u] & B
      \ar["{i_B}", l] \ar["{g}", ul, swap]
    \end{tikzcd}
  \]
  è indicato con \([f, g]\). Più in là avremo modo di introdurre una
  notazione ``matriciale'', che è quella che
  usa~\cite{buehler:exactcategories} e consente di fare alcuni conti
  molto più facilmente.
\end{notation}

\begin{proposition}\label{proposition:BinProdsAreBinCoprods}
  Sia \(\cat C\) una categoria preadditiva con oggetto zero \(0\) e
  \[
    \begin{tikzcd}[column sep=small]
      A & A \times B \ar["{p_A}", l, swap] \ar["{p_B}", r] & B
    \end{tikzcd}
  \]
  un prodotto in \(\cat C\).  Introduciamo anche le frecce
  \begin{equation}
    \label{eq:InjViaProj}
    \begin{aligned}
      & i_A := \left( \id_A, 0_A^B \right) : A \to A \times B \\
      & i_B := \left( 0_B^A, \id_B \right) : B \to A \times B
    \end{aligned}
  \end{equation}
  Allora
  \[
    \begin{tikzcd}[column sep=small]
      A \ar["{i_A}", r] & A \times B & B \ar["{i_B}", l, swap]
    \end{tikzcd}
  \]
  è coprodotto in \(\cat C\). Dualmente, se
  \[
    \begin{tikzcd}[column sep=small]
      A \ar["{i_A}", r] & A + B & B \ar["{i_B}", l, swap]
    \end{tikzcd}
  \]
  è un coprodotto e se introduciamo anche i morfismi
  \begin{equation}
    \label{eq:ProjViaInj}
    \begin{aligned}
      & p_A := \left[ \id_A, 0_B^A \right] : A + B \to A \\
      & p_B := \left[ 0_A^B, \id_B \right] : A + B \to B
    \end{aligned}
  \end{equation}
  allora
  \[
    \begin{tikzcd}[column sep=small]
      A & A + B \ar["{p_A}", l, swap] \ar["{p_B}", r] & B
    \end{tikzcd}
  \]
  è un prodotto in \(\cat C\).
\end{proposition}

In breve: in categorie preadditive si ha \(A \times B \cong A+B\).

\begin{proof}
  Possiamo limitarci a dimostrare solo il primo fatto. Consideriamo un
  qualsiasi oggetto con morfismi
  \[
    \begin{tikzcd}[column sep=small]
      A \ar["f", r] & C & B \ar["g", l, swap]
    \end{tikzcd}
  \]
  e cerchiamo un modo di costruire un morfismo \(A \times B \to C\). Le
  frecce \(f p_A\) e \(g p_B\) sono di questo tipo, ma non vanno bene
  per i nostri scopi. Invece la somma sì: il diagramma
  \[
    \begin{tikzcd}[row sep=large]
      & C \\
      A \ar["{i_A}", r, swap] \ar["f", ur, bend left] & A \times B
      \ar["{f p_A + g p_B}" description, u] & B \ar["{i_B}", l] \ar["g",
      ul, bend right, swap]
    \end{tikzcd}
  \]
  commuta a causa di come sono introdotti \(i_A\) e \(i_B\)
  in~\ref{eq:ProjViaInj}. Vediamo l'unicità ora. Supponiamo
  \(h : A \times B \to C\) tale che \(h i_A = f\) e \(h i_B =
  g\). Allora
  \[
    f p_A + g p_B = h i_A p_A + h i_B p_B = h (i_A p_A + i_B p_B) .
  \]
  Mostriamo che \(i_A p_A + i_B p_B : A \times B \to A \times B\) è
  l'identità. Precomponendo una volta per \(p_A\) e l'altra per \(p_B\)
  e usando di nuovo~\ref{eq:ProjViaInj}, si ha
  \begin{align*}
    & p_A (i_A p_A + i_B p_B) = \underbrace{p_A i_A}_{\id_A} p_A +
      \underbrace{p_A i_B}_{0_B^A} p_B = p_A \\
    & p_B (i_A p_A + i_B p_B) = \underbrace{p_B i_A}_{0_A^B} p_A +
      \underbrace{p_B i_B}_{\id_B} p_B = p_B .
  \end{align*}
  La proprietà universale di prodotto ci consente di concludere.
\end{proof}

\begin{definition}\label{definition:Biprodotto}
  Un {\em biprodotto} in una categoria preadditiva consta di oggetti e
  frecce
  \[
    \begin{tikzcd}
      A \ar["{i_A}", r, shift right, swap] & C \ar["{p_A}", l, shift
      right, swap] \ar["{p_B}", r, shift left] & B \ar["{i_B}", l, shift
      left]
    \end{tikzcd}
  \]
  tali che
  \begin{align}
    & p_A i_A = \id_A \label{eqn:Biprod1} \\
    & p_B i_B = \id_B \label{eqn:Biprod2}\\
    & i_A p_A + i_B p_B = \id_C \label{eqn:Biprod3}
  \end{align}
\end{definition}

\begin{remark}
  Dalle identità~\ref{eqn:Biprod1}, \ref{eqn:Biprod2}
  e~\ref{eqn:Biprod3} discendono
  \begin{align}
    & p_A i_B = 0_B^A \label{eqn:Biprod4} \\
    & p_B i_A = 0_A^B \label{eqn:Biprod5}
  \end{align}
  Proviamo solo la prima visto che l'altra si fa similmente.
  \[
    p_A \underbrace{=}_{\mathclap{\eqref{eqn:Biprod3}}} p_A \left( i_A
      p_A + i_B p_B \right)
    \underbrace{=}_{\mathclap{\eqref{eqn:Biprod1}}} p_A + p_A i_B p_B
  \]
  da cui
  \[
    p_A i_B p_B = 0_C^A .
  \]
  Postcomponendo con \(i_B\) e usando~\eqref{eqn:Biprod2}, concludiamo
  \(p_A i_B = 0_B^A\).
\end{remark}

\begin{proposition}
  I morfismi \(i_A\) e \(i_B\) della
  Definizione~\ref{definition:Biprodotto} sono monici. I morfismi
  \(p_A\) e \(p_B\) invece sono epici.
\end{proposition}

\begin{proof}
  Ad esempio, sia \(i_A f = i_A g\). Precomponendo ambo i mebri con
  \(p_A\), a causa di~\eqref{eqn:Biprod1}, si ha \(f = g\). Sia ora
  \(k p_A = h p_A\). Postcomponendo ambi membri per \(i_A\), sempre a
  causa di~\eqref{eqn:Biprod1}, si arriva a \(h = k\).
\end{proof}

Osserviamo come le
equazioni~\ref{eqn:Biprod1},~\ref{eqn:Biprod2},~\ref{eqn:Biprod3},~\ref{eqn:Biprod4}
e~\ref{eqn:Biprod5} sono già state incontrate nella
Proposizione~\ref{proposition:BinProdsAreBinCoprods} e nella relativa
dimostrazione. Non è un caso infatti.

\begin{proposition}\label{proposition:ProdsAndCoprodsAreBiprods}
  In una categoria preadditiva con oggetto zero \(0\), un prodotto
  \[
    \begin{tikzcd}[column sep=small]
      A & A \times B \ar["{p_A}", l, swap] \ar["{p_B}", r] & B
    \end{tikzcd}
  \]
  dà un biprodotto
  \[
    \begin{tikzcd}
      A \ar["{i_A}", r, shift right, swap] & A \times B \ar["{p_A}", l,
      shift right, swap] \ar["{p_B}", r, shift left] & B \ar["{i_B}", l,
      shift left]
    \end{tikzcd}
  \]
  in cui \(i_A\) e \(i_B\) sono introdotti come
  in~\eqref{eq:InjViaProj}. Dualmente, un coprodotto
  \[
    \begin{tikzcd}[column sep=small]
      A \ar["{i_A}", r] & A + B & B \ar["{i_B}", l, swap]
    \end{tikzcd}
  \]
  dà un biprodotto
  \[
    \begin{tikzcd}
      A \ar["{i_A}", r, shift right, swap] & A+B \ar["{p_A}", l, shift
      right, swap] \ar["{p_B}", r, shift left] & B \ar["{i_B}", l, shift
      left]
    \end{tikzcd}
  \]
  in cui \(p_A\) e \(p_B\) sono introdotti come
  in~\eqref{eq:ProjViaInj}.
\end{proposition}

\begin{proof}
  % Questa è una prosecuzione della dimostrazione della
  % Proposizione~\ref{proposition:BinProdsAreBinCoprods}.
  Verifichiamo ad esempio che i prodotti danno biprodotti. Le
  identità~\eqref{eqn:Biprod1}, \eqref{eqn:Biprod2}, \eqref{eqn:Biprod4}
  e~\eqref{eqn:Biprod5} discendono direttamente da come sono introdotte
  \(i_A\) e \(i_B\). Sempre nella dimostrazione della
  Proposizione~\ref{proposition:BinProdsAreBinCoprods} abbiamo visto che
  \(i_A p_A + i_B p_B = \id_{A \times B}\).
  % Consideriamo ora il morfismo
  % \[
  %   i_A p_A + i_B p_B : A \times B \to A \times B .
  % \]
  % Componendo una volta con \(p_A\) e l'altra con \(p_B\) si ha
  % \begin{align*}
  %   & p_A \left(i_A p_A + i_B p_B\right) = \underbrace{p_A i_A}_{= \id_A} p_A + \underbrace{p_A i_B}_{= 0_B^A} p_B = p_A \\
  %   & p_B \left(i_A p_A + i_B p_B\right) = \underbrace{p_B i_A}_{= 0_A^B} p_A + \underbrace{p_B i_B}_{= \id_B} p_B = p_B
  % \end{align*}
  % Per la proprietà universale di prodotto, si può concludere che
  % \[
  %   i_A p_A + i_B p_B = \id_{A \times B} . \qedhere
  % \]
\end{proof}

Vale anche il viceversa.

\begin{proposition}\label{proposition:BiprodsAreProdsAndCoprods}
  In una categoria preadditiva con oggetto zero \(0\) consideriamo il
  biprodotto
  \[
    \begin{tikzcd}
      A \ar["{i_A}", r, shift right, swap] & C \ar["{p_A}", l, shift
      right, swap] \ar["{p_B}", r, shift left] & B \ar["{i_B}", l, shift
      left]
    \end{tikzcd}
  \]
  allora la coppia di frecce \(p_A\) e \(p_B\) è prodotto e la coppia
  \(i_A\) e \(i_B\) è coprodotto.  In particolare, presi
  \(D \in \obj{\cat C}\) e una coppia di frecce
  uscenti \begin{tikzcd}[cramped, column sep=small] A & D \ar["{f}", l,
    swap] \ar["{g}", r] & B
  \end{tikzcd},
  \[
    (f, g) = i_A f + i_B g .
  \]
  Invece presi \(E \in \obj{\cat C}\) e una coppia di
  morfismi \begin{tikzcd}[cramped, column sep=small] A \ar["{h}", r] & E
    & B \ar["{k}", l, swap]
  \end{tikzcd},
  \[ [h, k] = h p_A + k p_B .
  \]
  Infine, notare anche che \(C \cong A \times B \cong A + B\).
\end{proposition}

\begin{proof}
  Facciamo solo la parte che riguarda il prodotto, perché l'altra si fa
  con un ragionamento duale. Grazie a~\eqref{eqn:Biprod1}
  e~\eqref{eqn:Biprod4} abbiamo
  \begin{align*}
    & p_A \left( i_A f + i_B g \right) = f \\
    & p_B \left( i_A f + i_B g \right) = g
  \end{align*}
  Ora se \(h : D \to C\) è tale che \(p_A h = f\) e \(p_B h = g\),
  allora
  \[
    h = \id_C h \underbrace{=}_{\mathclap{\eqref{eqn:Biprod3}}} \left(
      i_A p_A + i_B p_B \right) h = i_A f + i_B g .
  \]
  Possiamo quindi concludere che le frecce \(p_A\) e \(p_B\) formano un
  prodotto.
\end{proof}

La morale della storia è che in categorie preadditive esiste un modo
piuttosto compatto di esprimere prodotti e coprodotti (che sono la
stessa cosa) senza passare per le proprietà universali. E poiché
\(A \times B \cong A + B\), si decide di indicare uno qualsiasi di
questi oggetti con \(A \oplus B\).

\begin{definition}
  Una {\em categoria additiva} è una categoria che ha oggetto zero e che
  per ogni coppia di oggetti \(A\) e \(B\) possiede biprodotto
  \[
    \begin{tikzcd}
      A \ar["{i_A^{AB}}", r, shift right, swap] & A \oplus B
      \ar["{p_A^{AB}}", l, shift right, swap] \ar["{p_B^{AB}}", r, shift
      left] & B \ar["{i_B^{AB}}", l, shift left]
    \end{tikzcd}
  \]
\end{definition}

Spesso è ovvio dal contesto e quindi scriveremo semplicemente \(p_A\) al
posto di \(p_A^{AB}\) e così via.

\begin{example}
  \(\Modu_R\) è una categoria additiva. Siano \(M\) e \(N\) due
  \(R\)-moduli. Anche \(M \oplus N := M \times N\) con somma e moltiplicazione per
  scalare definita per componenti è un \(R\)-modulo. Consideriamo
  \[
    \begin{tikzcd}
      M \ar["{i_M}", r, shift right, swap] & M \oplus N
      \ar["{p_M}", l, shift right, swap] \ar["{p_N}", r, shift
      left] & N \ar["{i_N}", l, shift left]
    \end{tikzcd}
  \]
  dove \(p_M(m, n) = m\), \(p_N(m, n) = n\), \(i_M (m) = (m, 0)\) e
  \(i_N(n) = (0, n)\): questo è un biprodotto in \(\Modu_R\).
\end{example}

\begin{example}
  Siano \((X, \left\lVert \cdot \right\rVert_X)\) e
  \((Y, \left\lVert \cdot \right\rVert_Y)\) due spazi di Banach. Allora lo
  spazio vettoriale \(X \oplus Y\) con la norma
  \begin{align*}
    & \left\lVert \cdot \right\rVert_{X \oplus Y} : (X \oplus Y)^2 \to \mathbb{R} \\
    & \left\lVert (x, y)_{X \oplus Y} \right\rVert := \left\lVert x \right\rVert_X + \left\lVert y \right\rVert_Y
  \end{align*}
  è uno spazio di Banach. Un biprodotto in \(\Ban\) è della forma
  \[
    \begin{tikzcd}
      X \ar["{i_X}", r, shift right, swap] & X \oplus Y \ar["{p_X}", l, shift
      right, swap] \ar["{p_Y}", r, shift left] & Y \ar["{i_Y}", l, shift
      left]
    \end{tikzcd}
  \]
  con le proiezioni e le inclusioni definite come in \(\Modu_R\).
\end{example}

Vedendo \(A \oplus B\) come \(A \times B\), presi due morfismi
\(f : A \to B\) e \(g : C \to D\), definiamo
\(f \oplus g : A \oplus C \to B \oplus D\) come \(f \times g\), cioè
come l'unica freccia \(A \oplus C \to B \oplus D\) che fa commutare
\[
  \begin{tikzcd}
    A \ar["{f}", d, swap] & A \oplus C \ar["{p_A^{AC}}", l, swap]
    \ar["{}", d] \ar["{p_C^{AC}}", r] & C \ar["{g}", d] \\
    B & B \oplus D \ar["{p_B^{BD}}", l] \ar["{p_D^{BD}}", r, swap] & D
  \end{tikzcd}
\]
Sfruttando questa volta la proprietà universale di coprodotto, vedendo
\(A \oplus B\) come \(A + B\), si può definire \(f \oplus g\) come
\(f + g\).


\subsection{Notazione matriciale}

\begin{example}
  In generale, se \(R\) è un anello, possiamo considerare il modulo
  \[
    R^n : = \underbrace{R \oplus \dots{} \oplus R}_{n \text{ volte}}.
  \]
  Allora per ogni funzione lineare \(f : R^m \to R^n\), esiste un'unica
  matrice \(A\) ad entrate in \(R\) di tipo \(n \times m\) tale che
  \[
    f(x) = A x \text{ per ogni } x \in R^m .
  \]
  (Vedi~\cite{aluffi:algebra}.) Le entrate di \(A_{ij}\) sono elementi
  di \(R\), ma non è un problema reimmaginare \(A_{ij}\) come la
  funzione lineare
  \[
    R \to R\,,\ x \to A_{ij}x .
  \]
  Di conseguenza, \(A\) diventa una tabella di funzioni lineari
  \(A_{ij} : R \to R\). In tale caso, se si hanno due matrici \(A\) e
  \(B\) di tipo \(m \times n\) e \(n \times r\) e si vuole
  moltiplicarle, allora il prodotto \(A_{ij} B_{jk}\) di elementi di
  \(R\) può essere reinterpretato come composizione di due funzioni
  lineari.
\end{example}

Nell'esempio precedente abbiamo usato come \(R\)-moduli oggetti del tipo
\(R^n\). Tuttavia la notazione matriciale potrebbe essere esportata in
un caso più generale, in cui le entrate delle matrici non sono
endomorfismi di \(R\), ma in generale morfismi.

È questo quello che facciamo adesso, almeno per matrici piccole, del
tipo \(1 \times 2\), \(2 \times 1\) e \(2 \times 2\), e lo facciamo da
subito in una categoria additiva \(\cat C\) qualsiasi.

Dati due morfismi
\(\begin{tikzcd}[column sep=small, cramped] A & C \ar["{f}", l, swap]
  \ar["{g}", r] & B
\end{tikzcd}\), rinominiamo \((f, g) : C \to A \oplus B\) come una {\em
  matrice colonna}
\[
  \begin{pmatrix}
    f \\
    g
  \end{pmatrix} .
\]
Similmente, presi due morfismi
\(\begin{tikzcd}[column sep=small, cramped] A \ar["{f}", r] & C & B
  \ar["{g}", l, swap]
\end{tikzcd}\) riscriviamo \([f, g] : A \oplus B \to C\) come una {\em
  matrice riga}
\[
  \begin{pmatrix}
    f & g
  \end{pmatrix} .
\]
La composizione dei morfismi
\[
  \begin{tikzcd}[ampersand replacement=\&]
    C \ar["{\begin{psmallmatrix} f \\ g \end{psmallmatrix}}", r] \& A
    \oplus B \ar["{\begin{psmallmatrix} f' & g' \end{psmallmatrix}}", r]
    \& D
  \end{tikzcd}
\]
ricorda veramente l'usuale prodotto di una matrice \(1 \times 2\) per
una matrice \(2 \times 1\):
\[
  \begin{pmatrix}
    f' & g'
  \end{pmatrix} \begin{pmatrix}
    f \\ g
  \end{pmatrix}
  = f' f + g g'
\]
Una dimostrazione di questo fatto discende direttamente dalla
Proposizione~\ref{proposition:BiprodsAreProdsAndCoprods}

In particolare, notiamo che (vedi
Proposizione~\ref{proposition:BinProdsAreBinCoprods})
\begin{align*}
  & p_A =
    \begin{pmatrix}
      \id_A & 0_B^A
    \end{pmatrix} \\
  & p_B =
    \begin{pmatrix}
      0_A^B & \id_B
    \end{pmatrix} \\
  & i_A =
    \begin{pmatrix}
      \id_A \\ 0_A^B
    \end{pmatrix} \\
  & i_B =
    \begin{pmatrix}
      0_B^A \\ \id_B
    \end{pmatrix}
\end{align*}

Ora consideriamo i morfismi
\[
  \begin{tikzcd}[column sep=large]
    A \ar["{f_{AC}}", d, swap] \ar["{f_{AD}}" near start, dr] & B
    \ar["{f_{BC}}" near end, dl] \ar["{f_{BD}}", d] \\
    C & D
  \end{tikzcd}
\]
Qui possiamo costruire le frecce
% \begin{align*}
%   & \left[ f_{AC}, f_{BC} \right] : A \oplus B \to C \\
%   & \left[ f_{AD}, f_{BD} \right] : A \oplus B \to D
% \end{align*}
\begin{align*}
  & \begin{pmatrix} f_{AC} & f_{BC} \end{pmatrix} : A \oplus B \to C \\
  & \begin{pmatrix} f_{AD} & f_{BD} \end{pmatrix} : A \oplus B \to D
\end{align*}
da cui se ne origina un'altra
% \[
%   \left( \left[ f_{AC}, f_{BC} \right], \left[ f_{AD}, f_{BD} \right]
%   \right) : A \oplus B \to C \oplus D .
% \]
\[
  \begin{pmatrix}
    \begin{pmatrix} f_{AC} & f_{BC} \end{pmatrix} \\
    \begin{pmatrix} f_{AD} & f_{BD} \end{pmatrix}
  \end{pmatrix} : A \oplus B \to C \oplus D .
\]
Una notazione migliore è una matrice:
\[
  \begin{pmatrix}
    f_{AC} & f_{BC} \\
    f_{AD} & f_{BD}
  \end{pmatrix} : A \oplus B \to C \oplus D .
\]
In generale, scelti degli oggetti \(A_1, \dots, A_m\) e
\(B_1, \dots, B_n\) e morfismi \(f_{ij} : A_i \to B_j\) in \(\cat C\),
si può scrivere il morfismo indotto come sopra
\[
  \bigoplus_{i=1}^m A_i \to \bigoplus_{j=1}^n B_j
\]
come una matrice la cui entrata in posizione \((h, k)\) è
\(f_{k h} : A_k \to B_h \). (Attenzione ai pedici!)

Usando la definizione di biprodotto, si osserva facilmente che valgono
le usuali regole di addizione e moltiplicazione.



\subsection{Pullback e pushout}

Parliamo dei pullback e dei pushout ora. Sia \(\cat C\) una categoria
additiva e consideriamo in essa il quadrato commutativo
\[
  \begin{tikzcd}
    A \ar["{f}", r] \ar["{f'}", d, swap] & B \ar["{g}", d] \\
    C \ar["{g'}", r, swap] & D
  \end{tikzcd}
\]
e ``schiacciamo'' il tutto in questo modo
\[
  \begin{tikzcd}
    A \ar["{(f, f')}", r] & B \oplus C \ar["{[g, -g']}", r] & D
  \end{tikzcd}
\]
Il motivo per cui è \([g, -g']\) e non \([g, g']\) viene spiegato
subito. Grazie alla
Proposizione~\ref{proposition:BiprodsAreProdsAndCoprods}, abbiamo
un'espressione esplicita per \((f,f')\) e \([g,-g']\) e quindi:
\begin{align*} [g, -g'] (f, f') &= (g p_B + (-g') p_C) (i_B f + i_C f') = \\
                                &= g f - g' f' = 0_A^D .
\end{align*}
Quindi c'è la possibilità di inserirsi in un discorso in cui partecipano
pullback/pushout e kernel/cokernel.

\begin{proposition}\label{proposition:FromPullbackToKernel}
  In una categoria additiva,
  \[
    \begin{tikzcd}
      A \ar["{f}", r] \ar["{f'}", d, swap] & B \ar["{g}", d] \\
      C \ar["{g'}", r, swap] & D
    \end{tikzcd}
  \]
  è un quadrato di pullback se e solo se \((f, f') : A \to B \oplus C\)
  è kernel di \([g, -g'] : B \oplus C \to D\). Dualmente, lo stesso
  quadrato è di pushout se e solo se \([g, -g'] : B \oplus C \to D\) è
  cokernel di \((f, f') : A \to B \oplus C\).
\end{proposition}

\begin{proof}
  (\(\Rightarrow\)) In questo parte del lavoro è già fatto. Sia quindi
  \[
    \begin{tikzcd}
      E \ar["{h}", r] & B \oplus C \ar["{[g, -g']}", r, shift left]
      \ar["{0_{B \oplus C}^D}", r, shift right, swap] & D
    \end{tikzcd}
  \]
  commutativo. Abbiamo cioè \([g, -g'] h = g p_B h - g' p_C h = 0_E^D\),
  vale a dire commuta il quadrato esterno in
  \[
    \begin{tikzcd}
      E \ar["{p_B h}", drr, bend left] \ar["{p_C h}", ddr, swap,
      bend right] \\
      & {\color{gray} A} \ar["{f}" gray, gray, r, swap] \ar["{f'}" gray, gray, d] & B \ar["{g}", d] \\
      & C \ar["{g'}", r, swap] & D
    \end{tikzcd}
  \]
  Per la proprietà universale di pullback, esiste un unico
  \(k : E \to A\) per cui \(f k = p_B h\) e \(f' k = p_C h\). Rimane
  quindi da verificare che \((f, f') k = h\):
  \begin{align*}
    (f, f') k &= i_B \underbrace{f k}_{\crampedclap{=p_B h}} + i_C \underbrace{f' k}_{\crampedclap{=p_C h}} = \\
              &= \underbrace{(i_B p_B + i_C p_C)}_{\id_{B \oplus C}} h = h
  \end{align*}
  \(k\) è l'unico a fare ciò. Se \(k' : E \to A\) è tale che
  \((f, f') k' = h\), allora precomponendo una volta per \(p_B\) e
  un'altra per \(p_C\), abbiamo \(f k' = p_B h\) e \(f' k' = p_C h\). Ma
  questo, per la proprietà universale di pullback significa che
  \(k = k'\).\newline (\(\Leftarrow\)) Verifichiamo anzitutto che il quadrato è
  commutativo. Poiché \((f, f')\) è kernel di \([g, -g']\), allora
  \([g, -g'] (f, f') = 0_A^D\), e questo è un conto che abbiamo già
  fatto. Prendiamo ora un qualsiasi quadrato commutativo
  \[
    \begin{tikzcd}
      E \ar["{r}", r] \ar["{r'}", d, swap] & B \ar["{g}", d] \\
      C \ar["{g'}", r, swap] & D
    \end{tikzcd}
  \]
  Come abbiamo visto, possiamo ottenere
  \([g, -g'] (r, r') = 0_E^D = 0_{B \oplus C}^D (r, r')\). Per la proprietà
  universale di kernel, abbiamo che esiste uno e un solo \(s : E \to A\)
  tale che \((f, f') s = (r, r')\). Da qui, per concludere è sufficiente
  comporre una volta con \(p_B\) e un'altra con \(p_C\) entrambi i membri
  di quest'ultima uguaglianza.
\end{proof}


\subsection{Equalizzatori e coequalizzatori}

% Parliamo ora di equalizzatori e coequalizzatori. Il discorso è piuttosto
% semplice.

\begin{proposition}\label{proposition:EqualizersAreKernels}
  In una categoria preadditiva \(\cat C\) con oggetto zero \(0\), gli
  equalizzatori di
  \[
    \begin{tikzcd}
      A \ar["f", r, shift left] \ar["g", r, shift right, swap] & B
    \end{tikzcd}
  \]
  sono equalizzatori di
  \[
    \begin{tikzcd}
      A \ar["{f-g}", r, shift left] \ar["{0_A^B}", r, shift right, swap]
      & B
    \end{tikzcd}
  \]
  e viceversa. Analogamente vale per i coequalizzatori.
\end{proposition}

Quindi un (co)equalizzatore di una coppia di morfismi è un (co)kernel
della differenza dei due.

\begin{proof}
  Basta osservare che, preso \(i : E \to A\), si ha \(fi = gi\) se e solo se \((f-g)i = 0_EB\).
\end{proof}



\section{Categorie abeliane}

\begin{definition}\label{definition:AbelianCategories}
  Una {\em categoria abeliana} è una categoria additiva in cui:
  \begin{enumerate}[leftmargin=*]
  \item Ogni morfismo ha un kernel e un cokernel.
  \item Ogni monomorfismo è un kernel e ogni epimorfismo è un cokernel.
  \end{enumerate}
\end{definition}

\begin{example}
  Vediamo che il solito \(\Modu_R\) è una categoria abeliana. Abbiamo
  già visto che ogni omomorfismo ha kernel e cokernel. Sia
  \(f : M \to N\) un monomorfismo e cerchiamo \(g : N \to N'\) che abbia
  \(f\) come kernel. Se prendiamo \(N' = \frac{N}{\im f}\) e
  \(g = \pi_N\), abbiamo che \(\ker g = \im f\). I monomorfismi di
  \(\Modu_R\) sono iniettivi, quindi \(\ker g \cong N\). Ora invece sia
  \(f : M \to N\) epimorfismo di \(\Modu_R\), e quindi suriettivo e
  consideriamo
  \[
    \begin{tikzcd}[column sep=small]
      \ker f \ar["{}", r, hookrightarrow] & M \ar["{f}", r] & N
    \end{tikzcd}
  \]
  Abbiamo visto anche in questo caso che il cokernel dell'inclusione è
  \(\frac{M}{\ker f} \cong \im f = N\).
\end{example}

\begin{recall}
  In generale, una categoria \(\cat C\) che possiede oggetto terminale,
  prodotti binari e equalizzatori è {\em finitamente completa} (cioè:
  ogni diagramma \(X : \cat I \to \cat C\), con \(\cat I\) categoria con
  un numero finito di morfismi, ha un limite). Dualmente, una categoria
  che possiede oggetto iniziale, coprodotti binari e coequalizzatori è
  {\em finitamente cocompleta}.
\end{recall}

\begin{proposition}
  Le categorie abeliane sono finitamente complete e finitamente
  cocomplete.
\end{proposition}

\begin{proof}
  Le categorie abeliane hanno oggetto zero, biprodotti (cioè prodotti e
  coprodotti) e kernel e cokernel (cioè equalizzatori e coequalizzatori,
  vedi Proposizione~\ref{proposition:EqualizersAreKernels}).
\end{proof}

In generale, gli isomorfismi sono morfismi monici ed epici e il
viceversa non vale sempre. Le categorie abeliane sono categoria in cui
vale il viceversa.

\begin{recall}
  In generale, un equalizzatore epico è un isomorfismo; dualmente, un
  coequalizzatore monico è un isomorfismo.
\end{recall}

\begin{proposition}
  In una categoria abeliana, un morfismo monico ed epico è un
  isomorfismo.
\end{proposition}

\begin{proof}
  Sia \(f : A \to B\) monico ed epico: a causa della definizione di
  categoria abeliana, \(f\) è un certo equalizzatore e un certo
  coequalizzatore.
\end{proof}

\begin{recall}
  Se \(X\) e \(Y\) sono spazi topologici, \(Y\) è di Hausdorff, \(A\) è
  un sottospazio denso di \(X\), e \(f, g : X \to Y\) funzioni continue
  sono tali che
  \[
    f(x) = g(x) \text{ per ogni } x \in A
  \]
  allora \(f = g\). Ricordiamo anche che gli spazi di Banach sono spazi
  di Hausdorff.
\end{recall}

\begin{example}
  Al contrario di \(\Modu_R\), la categoria additiva \(\Ban\) non è
  abeliana. Sia \(M\) un sottospazio denso proprio di uno spazio di
  Banach \(X\): l'inclusione \(i : M \hookrightarrow X\) è monica ed epica, ma non è
  un isomorfismo. Ad esempio, \(C_c([a, b])\) è un sottospazio denso proprio di
  \(L^p([a, b])\).
\end{example}

\begin{proposition}\label{proposition:MonoIsKerOfItsCoker} 
  In una categoria abeliana, i monomorfismi sono kernel del rispettivo
  cokernel; dualmente, ogni epimorfismo è cokernel del rispettivo kernel.
\end{proposition}

\begin{proof}
  Sia \(f : A \to B\) un monomorfismo e \(p : B \to C\) tale che \(f\) è
  kernel di \(p\). Sia ora \(q : B \to D\) cokernel di \(f\). Poiché
  \(p f = 0_A^C\), allora a causa della proprietà universale di cokernel
  esiste \(r : D \to C\) per cui commuta il triangolo in
  \[
    \begin{tikzcd}[row sep=small]
      & & C \\
      A \ar["{f}", r] & B \ar["{p}", ur] \ar["{q}", dr, swap] \\
      & & D \ar["{r}", uu, swap]
    \end{tikzcd}
  \]
  Per provare che \(f : A \to B\) è kernel di \(q\) sia
  \[
    \begin{tikzcd}
      A' \ar["{f'}", r] & B \ar["{q}", r, shift left] \ar["{0_B^D}", r,
      shift right, swap] & D
    \end{tikzcd}
  \]
  commutativo. In tal caso \(pf' = rqf' = r 0_{A'}^D = 0_{A'}^C\), da
  cui, essendo \(f\) kernel di \(p\), si ha \(f' = f e\) per un
  \(e : A' \to A\). Per l'unicità, basta ricordare che \(f\) è monico: se
  \(f' = fe'\) con \(e' : A' \to A\), allora \(e = e'\).
\end{proof}

\begin{proposition}\label{proposition:PushotMonoIsMono}
  In una categoria abeliana, il pushout di un monomorfismo è un
  monomorfismo; dualmente, il pullback di un epimorfismo è un epimorfismo.
\end{proposition}

\begin{proof}
  Sia \(f : A \to B\) monico e
  \[
    \begin{tikzcd}
      A \ar["{g}", d, swap] \ar["{f}", r] & B \ar["{g'}", d] \\
      A' \ar["{f'}", r, swap] & B'
    \end{tikzcd}
  \]
  un quadrato di pushout. Grazie alla
  Proposizione~\ref{proposition:FromPullbackToKernel}, segue che
  \([f', -g'] : A' \oplus B \to B'\) è cokernel di
  \((g, f) : A \to A' \oplus B\). Tuttavia di quest'ultima freccia,
  possiamo dire che è un monomorfismo perché \(f\) lo è. Invocando la
  Proposizione~\ref{proposition:MonoIsKerOfItsCoker}, \((g, f)\) deve
  essere anche kernel di \([f', -g']\).\newline Passiamo a mostrare che
  \(f'\) è un monomorfismo. Sia \(h : E \to A'\) tale che \(f'h = 0_E^{B'}\)
  e mostriamo che \(h = 0_E^{A'}\). Abbiamo quindi
  \(0_E^{B'} = f'h = [f', -g']i_{A'}h\) da cui segue che
  \(i_{A'} h = (g, f) u\) per un \(u : E \to A\), essendo
  \((g, f)\) kernel di \([f', -g']\). Applicando \(p_B\) ad entrambi i
  membri, otteniamo \(fu = 0_E^B\) che a sua volta implica che \(u =
  0_E^A\). Quindi anche \(i_{A'} h = 0_E^A\), da
  cui segue, applicando \(p_{A'}\), che \(h = 0_E^{A'}\).
\end{proof}



%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "../main"
%%% TeX-engine: luatex
%%% ispell-local-dictionary: "italian"
%%% End:
