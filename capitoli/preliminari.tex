
\chapter{Preliminari}

In queste note si assume almeno la {\sc Teoria delle Categorie} che si
può imparare da~\cite{leinster:categories}. Un altro validissimo testo è
anche~\cite{riehl:categories}. Un vero e proprio classico che contiene
anche nozioni sulle categorie preadditive
è~\cite{maclane:categories}. In lingua italiana,
esiste la playlist~\cite{itaca:categorie} realizzata dal {\em Progetto ItaCa}.



\section{Kernel e cokernel}

Noi lavoreremo con categorie in cui sono presenti oggetti che sono sia
terminali che iniziali. Oggetti di questo tipo sono detti {\em oggetti
  zero}. Non si tratta di categorie come \(\Set\), \(\Top\) e \(\Ring\),
ma è il caso di \(\Grp\) e \(\Modu_R\), con \(R\) anello.

\begin{definition}
  Sia \(\cat C\) una categoria con {\em oggetto zero} che indichiamo con
  \(0\). Per \(A, B \in \obj{\cat C}\), il {\em morfismo nullo} o {\em
    zero} da \(A\) a \(B\) è la composizione dei morfismi
  \[
    \begin{tikzcd}[column sep=small]
      A \ar["{\exists!}", r] & 0 \ar["{\exists!}", r] & B
    \end{tikzcd}
  \]
  Scriveremo questo morfismo come \(0_A^B\) oppure, se dal contesto è
  chiaro, semplicemente \(0\).
\end{definition}

\begin{example}
  In casi come \(\Grp\) e \(\Modu_R\), il morfismo nullo è quello che
  manda tutti gli elementi del dominio nell'identità. Anche \(\Ring\)
  possiede omomorfismi come questi; tuttavia in \(\Ring\) l'oggetto
  iniziale è \(\mathbb{Z}\) che non è terminale mentre i morfismi zero sono
  definiti attraverso oggetti zero.
\end{example}

Comporre con un morfismo nullo dà un morfismo nullo. Più precisamente:

\begin{proposition}\label{lemma:CompCon0}
  Sia \(\cat C\) una categoria con {\em oggetto zero} \(0\), e
  \(A, B, C \in \obj{\cat C}\). Allora per ogni \(f : B \to C\) di
  \(\cat C\) si ha
  \[
    f 0_A^B = 0_A^C
  \]
  e per ogni \(g : C \to A\) di \(\cat C\) si ha
  \[
    0_A^B g = 0_C^B .
  \]
\end{proposition}

\begin{proof}
  Proviamo solo una delle due uguaglianze perché l'altra è
  simile. Consideriamo i morfismi
  \[
    \begin{tikzcd}[column sep=small]
      A \ar["{\exists!}", r] & 0 \ar["{\exists!}", r] & B \ar["f", r] & C
    \end{tikzcd}
  \]
  Poiché \(0\) è iniziale, la composizione delle ultime due frecce è
  l'unica che può esserci. Quindi \(f 0_A^B\) è la composizione della
  freccia \(A \to 0\) con la freccia \(0 \to C\), ed abbiamo concluso.
\end{proof}

\begin{definition}
  In una categoria \(\cat C\) con oggetto zero \(0\), il {\em kernel} di
  \(f : A \to B\) è uno qualsiasi degli equalizzatori di
  \[
    \begin{tikzcd}
      A \ar["f", shift left, r] \ar["{0_A^B}", shift right, swap, r] & B
    \end{tikzcd}
  \]
  Dualmente, il {\em cokernel} di \(f : A \to B\) è uno qualsiasi dei
  coequalizzatori della stessa coppia di morfismi.
\end{definition}

\begin{remark}
  Ricordiamo che in generale gli equalizzatori sono monomorfismi e i
  coequalizzatori sono epimorfismi. Questa informazione può dare delle
  indicazioni su come sono fatti i kernel e i cokernel in categorie in
  cui monomorfismo ed epimorfismo significano rispettivamente iniettivo
  e suriettivo.
\end{remark}

\begin{example}[Kernel di omomorfismi di moduli]\label{example:KernelInModR}
  In Algebra, si parla di {\em kernel} di morfismi in vari ambiti. Per
  esempio, se \(M\) e \(N\) sono due moduli su un fissato anello \(R\)
  e \(f : M \to N\) è un omomorfismo, allora
  \[
    \ker f := \set{x \in M \mid f(x) = 0_N}
  \]
  è un sottomodulo di \(M\). Per entrare nel linguaggio della {\sc
    Teoria delle Categorie},
  \begin{quotation}
    l'omomorfismo inclusione \(i : \ker f \hookrightarrow M\) è un equalizzatore
    della coppia di omomorfismi
    \[
      \begin{tikzcd}
        M \ar["f", shift left, r] \ar["{0_M^N}", shift right, swap, r]
        & N
      \end{tikzcd}
    \]
  \end{quotation}
  % Verifichiamo l'affermazione. Anzitutto, è facile vedere che
  % \(f \circ i = 0_M^N \circ i\), poiché per la
  % Proposizione~\ref{lemma:CompCon0} si ha che
  % \(0_M^N \circ i = 0_{\ker f}^N\). Consideriamo ora invece un qualsiasi
  % diagramma commutativo
  % \[
  %   \begin{tikzcd}
  %     E \ar["j", r] & M \ar["f", shift left, r] \ar["{0_M^N}", shift
  %     right, swap, r] & N
  %   \end{tikzcd}
  % \]
  % Questo implica che \(f(j(x)) = 0_M^N (j(x)) = 0_N\) per ogni
  % \(x \in E\). Questo significa che le immagini di \(j\) stanno in
  % \(\ker f\), quindi è possibile la fattorizzazione \(j = i \circ k\) dove
  % \(k : E \hookrightarrow \ker f\) è una semplice inclusione. Per finire
  % \(k\) è l'unico omomorfismo \(E \to \ker f\) per cui commuta il
  % triangolo
  % \[
  %   \begin{tikzcd}
  %     \ker f \ar["i", r] & M \\
  %     E \ar[u] \ar["j", ur, swap]
  %   \end{tikzcd}
  % \]
  % a causa dell'iniettività di \(i\).
\end{example}

\begin{example}[Cokernel di omomorfismi di moduli]\label{example:CokernelInModR}
  Se \(M\) e \(N\) sono due moduli su un fissato anello \(R\) e
  \(f : M \to N\) è un omomorfismo, allora
  \[
    \coker f := \frac{N}{\im f}
  \]
  è un sottomodulo di \(M\) chiamato {\em cokernel} di \(f\). Questa
  nozione è il duale di kernel, nel senso che
  \begin{quotation}
    l'omomorfismo di proiezione canonica al quoziente
    \(\pi_N : N \to \coker f\) è un coequalizzatore della coppia di
    omomorfismi
    \[
      \begin{tikzcd}
        M \ar["f", shift left, r] \ar["{0_M^N}", shift right, swap, r]
        & N
      \end{tikzcd}
    \]
  \end{quotation}
  % Per dimostrare questo fatto si può usare un teorema di omomorfismo,
  % oppure un argomento categoriale come questo.
  % \begin{enumerate}
  % \item Considerare il funtore dimenticante \(U : \Modu_R \to \Set\) che
  %   è fedele.
  % \item In \(\Set\) un coequalizzatore di
  %   \[
  %     \begin{tikzcd}
  %       X \ar["f", r, shift left] \ar["g", r, shift right, swap] & Y
  %     \end{tikzcd}
  %   \]
  %   è la proiezione canonica al quoziente \(p : Y \to Y{/}\sim\) dove
  %   \(\sim\) è la relazione di equivalenza generata da
  %   \(f(a) \sim f(b)\) al variare di \(a, b \in X\).
  % \item Se \(M\) è un modulo su \(R\) e \(H\) è un suo sottomodulo, il
  %   modulo quoziente \(\frac{M}{H}\) è ottenuto quozientando \(M\) con
  %   la relazione di equivalenza \(\sim\) generata da \(x+h \sim x\) per
  %   \(x \in M, h \in H\).
  % \end{enumerate}
\end{example}

\begin{remark}
  In Algebra, kernel e cokernel sono degli oggetti, mentre
  tecnicamente come sono definiti qui sono dei morfismi.
\end{remark}



\section{Categorie preadditive}

\begin{definition}
  Una {\em categoria preadditiva} è una categoria \(\cat C\) in cui:
  \begin{enumerate}[leftmargin=*]
  \item Per ogni \(A, B \in \obj{\cat C}\) la classe \(\cat C(A, B)\) è
    dotata di un'operazione interna
    \[
      +_{A,B} : \cat C (A, B) \times \cat C (A, B) \to \cat C (A, B)
    \]
    e ha un elemento \(0_A^B : A \to B\) che lo rendono un gruppo
    abeliano.
  \item Per ogni \(A, B, C, D \in \obj{\cat C}\) e \(f : A \to B\) di
    \(\cat C\), le funzioni
    \begin{align*}
      & f_\ast := \cat C(C, f) : \cat C(C, A) \to \cat C(C, B) \\
      & f^\ast := \cat C(f, D) : \cat C(B, D) \to \cat C(A, D)
    \end{align*}
    sono omomorfismi di gruppi abeliani.
  \end{enumerate}
\end{definition}

\begin{recall}
  Ricordiamo che
  \begin{align*}
    & f_\ast(g) := f g \\
    & f^\ast(h) := h f
  \end{align*}
\end{recall}

Spesso scriveremo semplicemente \(+\) senza pedici, perché in genere è
chiaro di quali frecce stiamo sommando.

Inoltre, come nei primi teoremi di Algebra, il morfismo zero è l'unico
elemento neutro e per ogni \(f : a \to b\) è unico l'opposto. In
coerenza con la notazione additiva indichiamo con \(- f\) l'opposto di
\(f : a \to b\).

\begin{example}[\(\Modu_R\)] {\color{red} [Scrivere esempio.]}
\end{example}

Un'altra osservazione da fare è questa. Il simbolo \(0_A^B\) in una
categoria \(\cat C\) con oggetto zero indica il morfismo zero
\(A \to B\). Se \(\cat C\) è preaddittiva, non sono notazioni in
conflitto?  No.

\begin{proposition}
  In una categoria preadditiva \(\cat C\) con oggetto zero \(0\), il
  morfismo nullo è elemento neutro.
\end{proposition}

\begin{proof}
  Poiché \(0\) è iniziale, \(\cat C(0, B)\) è banale e in particolare
  \(0_0^B\) è elemento neutro. L'omomorfismo
  \[
    \left(0_A^0\right)^\ast : \cat C(0, B) \to \cat C(A, B)
  \]
  manda l'elemento neutro del dominio in quello del codominio, che è
  \[
    \left(0_A^0\right)^\ast\left(0_0^B\right) = 0_0^B 0_A^0 = 0_A^B
    . \qedhere
  \]
\end{proof}

\begin{remark}
  A tal proposito è utile osservare che se \(\cat C\) è una categoria
  preadditiva, anche il suo duale \(\opcat C\) lo è. La conseguenza più
  pratica per noi è che dimezza le dimostrazioni: una volta dimostrato
  un enunciato, quello duale è automatico.
\end{remark}

Un mantra dell'Algebra è che un omomorfismo è iniettivo se e solo se è
il suo kernel è banale. Questo continua a valere, con qualche
precauzione, anche nelle categorie preadditive.

\begin{proposition}\label{proposition:MonoIffKerIsTrivial}
  Sia \(\cat C\) una categoria preadditiva con oggetto zero
  \(0\). Allora \(f : A \to B\) è monomorfismo se e solo se
  \(\begin{tikzcd}[column sep=small, cramped] 0 \ar["{\exists!}", r] &
    A \end{tikzcd}\) è kernel di \(f\).
\end{proposition}

\begin{proof}
  (\Rightarrow) Questa implicazione è valida in qualsiasi categoria con
  oggetto zero. Sia
  \[
    \begin{tikzcd}
      E \ar["{i}", r] & A \ar["{f}", r, shift left] \ar["{0_A^B}", r,
      shift right, swap] & B
    \end{tikzcd}
  \]
  commutativo. Allora
  \[
    f i = 0_A^B i = 0_E^B = f 0_E^A
  \]
  Essendo \(f\) un monomorfismo, allora \(i = 0_E^A\). Pertanto \(i\)
  fattorizza attraverso \(0 \to A\) in un unico modo (\(0\) è terminale):
  \[
    \begin{tikzcd}
      0 \ar["{\exists!}", r] & A \\
      E \ar["{\exists!}", u] \ar["{i = 0_E^A}", ur, swap]
    \end{tikzcd}
  \]
  (\Leftarrow) Siano \(h, k : A' \to A\) tali che \(f h = f k\). Questo
  vuol dire che \(f (h-k) = 0_E^B = 0_A^B (h-k)\). Per la definizione di
  kernel, esiste un e un solo morfismo \(j : A' \to 0\) tale che
  \(h-k = 0_0^A j = 0_{A'}^A\). In conclusione, \(h = k\).
\end{proof}


\section{Limiti e limiti}

Ora parleremo di alcune peculiarità dei limiti e dei colimiti in
categorie preadditive.


\subsection{Oggetti iniziali e terminali}

\begin{proposition}
  In un categoria preadditiva \(\cat C\) gli oggetti terminali sono
  iniziali e viceversa.
\end{proposition}

Quindi in una categoria preadditiva gli oggetti terminali e iniziali
sono oggetti zero.

\begin{proof}
  Sia \(T\) un oggetto terminale di \(\cat C\). Se riusciamo a mostrare
  che \(\cat C(T, A)\) è un gruppo banale per ogni oggetto \(A\) di
  \(\cat C\), allora possiamo concludere.\newline Prendiamo un
  \(f : T \to A\) qualsiasi in \(\cat C\) e guardiamo l'omomorfismo di
  gruppi
  \[
    f_\ast = \cat C(T, f) : \cat C(T, T) \to \cat C(T, A) .
  \]
  Il dominio è un gruppo banale perché \(T\) è terminale; in
  particolare, \(\id_T = 0_T^T\). Inoltre, trattandosi di omomorfismo,
  \[
    \underbrace{f_\ast \left(\id_T\right)}_{= f} = f 0_T^T = 0_T^A
    . \qedhere
  \]
\end{proof}


\subsection{Prodotti, coprodotti e biprodotti}

Vediamo i prodotti e i coprodotti finiti ora.

\begin{notation}
  A proposito di notazioni, seguiamo~\cite{leinster:categories}
  e~\cite{riehl:categories}. Più precisamente, preso un prodotto
  \[
    \begin{tikzcd}[column sep=small]
      A & A \times B \ar["{p_A}", l, swap] \ar["{p_B}", r] & B
    \end{tikzcd}
  \]
  il morfismo \(C \to A \times B\) che fa commutare il diagramma
  \[
    \begin{tikzcd}
      & C \ar["{f}", dl, swap] \ar[d] \ar["{g}", dr] \\
      A & A \times B \ar["{p_A}", l] \ar["{p_B}", r, swap] & B
    \end{tikzcd}
  \]
  è indicato con \((f, g)\); invece, dato un coprodotto
  \[
    \begin{tikzcd}[column sep=small]
      A \ar["{i_A}", r] & A + B & B \ar["{i_B}", l, swap]
    \end{tikzcd}
  \]
  il morfismo \(A+B \to C\) che rende commutativo
  \[
    \begin{tikzcd}
      & A \\
      A \ar["{i_A}", r, swap] \ar["{f}", ur] & A + B \ar[u] & B
      \ar["{i_B}", l] \ar["{g}", ul, swap]
    \end{tikzcd}
  \]
  è indicato con \([f, g]\). Più in là avremo modo di introdurre una
  notazione ``matriciale'', che è quella che
  usa~\cite{buehler:exactcategories} e consente di fare alcuni conti
  molto più facilmente.
\end{notation}

Più in là avremo modo di introdurre una notazione ``matriciale'', che è
quella che usa~\cite{buehler:exactcategories} e consente di fare alcuni
conti molto più facilmente.

\begin{proposition}\label{proposition:BinProdsAreBinCoprods}
  Sia \(\cat C\) una categoria preadditiva con oggetto zero \(0\) e
  \[
    \begin{tikzcd}[column sep=small]
      A & A \times B \ar["{p_A}", l, swap] \ar["{p_B}", r] & B
    \end{tikzcd}
  \]
  un prodotto in \(\cat C\).  Introduciamo anche le frecce
  \begin{equation}
    \label{eq:InjViaProj}
    \begin{aligned}
      & i_A := \left( \id_A, 0_A^B \right) : A \to A \times B \\
      & i_B := \left( 0_B^A, \id_B \right) : B \to A \times B
    \end{aligned}
  \end{equation}
  Allora
  \[
    \begin{tikzcd}[column sep=small]
      A \ar["{i_A}", r] & A \times B & B \ar["{i_B}", l, swap]
    \end{tikzcd}
  \]
  è coprodotto in \(\cat C\). Dualmente, se
  \[
    \begin{tikzcd}[column sep=small]
      A \ar["{i_A}", r] & A + B & B \ar["{i_B}", l, swap]
    \end{tikzcd}
  \]
  è un coprodotto e se introduciamo anche i morfismi
  \begin{equation}
    \label{eq:ProjViaInj}
    \begin{aligned}
      & p_A := \left[ \id_A, 0_B^A \right] : A + B \to A \\
      & p_B := \left[ 0_A^B, \id_B \right] : A + B \to B
    \end{aligned}
  \end{equation}
  allora
  \[
    \begin{tikzcd}[column sep=small]
      A & A + B \ar["{p_A}", l, swap] \ar["{p_B}", r] & B
    \end{tikzcd}
  \]
  è un prodotto in \(\cat C\).
\end{proposition}

In breve: in categorie preadditive si ha \(A \times B \cong A+B\).

\begin{proof}
  Possiamo limitarci a dimostrare solo il primo fatto. Consideriamo un
  qualsiasi oggetto con morfismi
  \[
    \begin{tikzcd}[column sep=small]
      A \ar["f", r] & C & B \ar["g", l, swap]
    \end{tikzcd}
  \]
  e cerchiamo un modo di costruire un morfismo \(A \times B \to C\). Le
  frecce \(f p_A\) e \(g p_B\) sono di questo tipo, ma non vanno bene
  per i nostri scopi. Invece la somma sì: il diagramma
  \[
    \begin{tikzcd}[row sep=large]
      & C \\
      A \ar["{i_A}", r, swap] \ar["f", ur, bend left] & A \times B
      \ar["{f p_A + g p_B}" description, u] & B \ar["{i_B}", l] \ar["g",
      ul, bend right, swap]
    \end{tikzcd}
  \]
  commuta.
\end{proof}

\begin{definition}\label{definition:Biprodotto}
  Un {\em biprodotto} in una categoria preadditiva consta di oggetti e
  frecce
  \[
    \begin{tikzcd}
      A \ar["{i_A}", r, shift right, swap] & C \ar["{p_A}", l, shift
      right, swap] \ar["{p_B}", r, shift left] & B \ar["{i_B}", l, shift
      left]
    \end{tikzcd}
  \]
  tali che
  \begin{align}
    & p_A i_A = \id_A \label{eqn:Biprod1} \\
    & p_B i_B = \id_B \label{eqn:Biprod2}\\
    & i_A p_A + i_B p_B = \id_C \label{eqn:Biprod3}
  \end{align}
\end{definition}

\begin{remark}
  Dalle identità~\ref{eqn:Biprod1}, \ref{eqn:Biprod2}
  e~\ref{eqn:Biprod3} discendono
  \begin{align}
    & p_A i_B = 0_B^A \label{eqn:Biprod4} \\
    & p_B i_A = 0_A^B \label{eqn:Biprod5}
  \end{align}
  Proviamo solo la prima visto che l'altra si fa similmente.
  \[
    p_A \underbrace{=}_{\mathclap{\eqref{eqn:Biprod3}}} p_A \left( i_A
      p_A + i_B p_B \right)
    \underbrace{=}_{\mathclap{\eqref{eqn:Biprod1}}} p_A + p_A i_B p_B
  \]
  da cui
  \[
    p_A i_B p_B = 0_C^A .
  \]
  Postcomponendo con \(i_B\) e usando~\eqref{eqn:Biprod2}, concludiamo
  \(p_A i_B = 0_B^A\).
\end{remark}

Un'altra proprietà utile per il futuro è questa.

\begin{proposition}
  I morfismi \(i_A\) e \(i_B\) della
  Definizione~\ref{definition:Biprodotto} sono monici. I morfismi
  \(p_A\) e \(p_B\) invece sono epici.
\end{proposition}

\begin{proof}
  Ad esempio, sia \(i_A f = i_A g\). Precomponendo ambo i mebri con
  \(p_A\), a causa di~\eqref{eqn:Biprod1}, si ha \(f = g\). Sia ora
  \(k p_A = h p_A\). Postcomponendo ambi membri per \(i_A\), sempre a
  causa di~\eqref{eqn:Biprod1}, si arriva a \(h = k\).
\end{proof}

I biprodotti sono prodotti e coprodotti binari.

\begin{proposition}\label{proposition:BiprodsAreProdsAndCoprods}
  In una categoria preadditiva con oggetto zero \(0\) consideriamo il
  biprodotto
  \[
    \begin{tikzcd}
      A \ar["{i_A}", r, shift right, swap] & C \ar["{p_A}", l, shift
      right, swap] \ar["{p_B}", r, shift left] & B \ar["{i_B}", l, shift
      left]
    \end{tikzcd}
  \]
  allora la coppia di frecce \(p_A\) e \(p_B\) è prodotto e la coppia
  \(i_A\) e \(i_B\) è coprodotto.  In particolare, presi
  \(D \in \obj{\cat C}\) e una coppia di frecce
  uscenti \begin{tikzcd}[cramped, column sep=small] A & C \ar["{f}", l,
    swap] \ar["{g}", r] & B
  \end{tikzcd},
  \[
    (f, g) = i_A \circ f + i_B \circ g .
  \]
  Invece presi \(e \in \obj{\cat C}\) e una coppia di
  morfismi \begin{tikzcd}[cramped, column sep=small] A \ar["{h}", r] & C
    & B \ar["{k}", l, swap]
  \end{tikzcd},
  \[ [h, k] = h \circ p_A + k \circ p_B .
  \]
  Infine, notare anche che \(C \cong A \times B \cong A + B\).
\end{proposition}

\begin{proof}
  Facciamo solo la parte che riguarda il prodotto, perché l'altra si fa
  con un ragionamento non tanto diverso. Grazie a~\eqref{eqn:Biprod1}
  e~\eqref{eqn:Biprod4} abbiamo
  \begin{align*}
    & p_A \circ \left( i_A \circ f + i_B \circ g \right) = f \\
    & p_B \circ \left( i_A \circ f + i_B \circ g \right) = g
  \end{align*}
  Ora se \(h : D \to C\) è tale che \(p_A \circ h = f\) e
  \(p_B \circ h = g\), allora
  \[
    h = \id_C \circ h \underbrace{=}_{\mathclap{\eqref{eqn:Biprod3}}}
    \left( i_A \circ p_A + i_B \circ p_B \right) \circ h = i_A \circ f +
    i_B \circ g .
  \]
  Possiamo quindi concludere che le frecce \(p_A\) e \(p_B\) formano un
  prodotto.
\end{proof}

Vale anche il viceversa.

\begin{proposition}\label{proposition:ProdsAndCoprodsAreBiprods}
  In una categoria preadditiva con oggetto zero \(0\), un prodotto
  \[
    \begin{tikzcd}[column sep=small]
      A & A \times B \ar["{p_A}", l, swap] \ar["{p_B}", r] & B
    \end{tikzcd}
  \]
  dà un biprodotto
  \[
    \begin{tikzcd}
      A \ar["{i_A}", r, shift right, swap] & A \times B \ar["{p_A}", l,
      shift right, swap] \ar["{p_B}", r, shift left] & B \ar["{i_B}", l,
      shift left]
    \end{tikzcd}
  \]
  in cui \(i_A\) e \(i_B\) sono introdotti come
  in~\eqref{eq:InjViaProj}. Dualmente, un coprodotto
  \[
    \begin{tikzcd}[column sep=small]
      A \ar["{i_A}", r] & A + B & B \ar["{i_B}", l, swap]
    \end{tikzcd}
  \]
  dà un biprodotto
  \[
    \begin{tikzcd}
      A \ar["{i_A}", r, shift right, swap] & A+B \ar["{p_A}", l, shift
      right, swap] \ar["{p_B}", r, shift left] & B \ar["{i_B}", l, shift
      left]
    \end{tikzcd}
  \]
  in cui \(p_A\) e \(p_B\) sono introdotti come
  in~\eqref{eq:ProjViaInj}.
\end{proposition}

\begin{proof}
  Questa è una prosecuzione della dimostrazione della
  Proposizione~\ref{proposition:BinProdsAreBinCoprods}. Verifichiamo ad
  esempio che i prodotti danno biprodotti. Le
  identità~\eqref{eqn:Biprod1}, \eqref{eqn:Biprod2}, \eqref{eqn:Biprod4}
  e~\eqref{eqn:Biprod5} discendono direttamente da come sono introdotte
  \(i_A\) e \(i_B\). Consideriamo ora il morfismo
  \[
    (f, g) = i_A f + i_B g .
  \]
  Componendo una volta con \(p_A\) e l'altra con \(p_B\) si ha
  \begin{align*}
    & p_A \left( i_A f + i_B g \right) = f \\
    & p_B \left( i_A f + i_B g \right) = g
  \end{align*}
  Ora se \(h : D \to C\) è tale che \(p_A h = f\) e \(p_B h = g\),
  allora
  \[
    h = \id_C h \underbrace{=}_{\mathclap{\eqref{eqn:Biprod3}}} \left(
      i_A p_A + i_B p_B \right) h = i_A f + i_B g .
  \]
  Possiamo quindi concludere che le frecce \(p_A\) e \(p_B\) formano un
  prodotto.
\end{proof}

La morale della storia è che in categorie preadditive esiste un modo
piuttosto compatto di esprimere prodotti e coprodotti (che sono la
stessa cosa) senza passare per le proprietà universali. E poiché
\(A \times B \cong A + B\), si decide di indicare uno qualsiasi di
questi oggetti con \(A \oplus B\).

\begin{definition}
  Una {\em categoria additiva} è una categoria che ha oggetto zero e che
  per ogni coppia di oggetti \(A\) e \(B\) possiede biprodotto
  \[
    \begin{tikzcd}
      A \ar["{i_A^{AB}}", r, shift right, swap] & A \oplus B
      \ar["{p_A^{AB}}", l, shift right, swap] \ar["{p_B^{AB}}", r, shift
      left] & B \ar["{i_B^{AB}}", l, shift left]
    \end{tikzcd}
  \]
\end{definition}

Spesso è ovvio dal contesto e quindi scriveremo semplicemente \(p_A\) al
posto di \(p_A^{AB}\) e così via.

Vedendo \(A \oplus B\) come \(A \times B\), presi due morfismi
\(f : A \to B\) e \(g : C \to D\), definiamo
\(f \oplus g : A \oplus C \to B \oplus D\) come \(f \times g\), cioè
come l'unica freccia \(A \oplus C \to B \oplus D\) che fa commutare
\[
  \begin{tikzcd}
    A \ar["{f}", d, swap] & A \oplus C \ar["{p_A^{AC}}", l, swap]
    \ar["{}", d] \ar["{p_C^{AC}}", r] & C \ar["{g}", d] \\
    B & B \oplus D \ar["{p_B^{BD}}", l] \ar["{p_D^{BD}}", r, swap] & D
  \end{tikzcd}
\]
Sfruttando questa volta la proprietà universale di coprodotto, vedendo
\(A \oplus B\) come \(A + B\), si può definire \(f \oplus g\) come
\(f + g\).


\subsection{Pullback e pushout}

Parliamo dei pullback e dei pushout ora. Sia \(\cat C\) una categoria
additiva e consideriamo in essa il quadrato commutativo
\[
  \begin{tikzcd}
    A \ar["{f}", r] \ar["{f'}", d, swap] & B \ar["{g}", d] \\
    C \ar["{g'}", r, swap] & D
  \end{tikzcd}
\]
e ``schiacciamo'' il tutto in questo modo
\[
  \begin{tikzcd}
    A \ar["{(f, f')}", r] & B \oplus C \ar["{[g, -g']}", r] & D
  \end{tikzcd}
\]
Il motivo per cui è \([g, -g']\) e non \([g, g']\) viene spiegato
subito. Grazie alla
Proposizione~\ref{proposition:BiprodsAreProdsAndCoprods}, abbiamo
un'espressione esplicita per \((f,f')\) e \([g,-g']\) e quindi:
\begin{align*} [g, -g'] (f, f') &= (g p_B + (-g') p_C) (i_B f + i_C f') = \\
                                &= g f - g' f' = 0_A^D .
\end{align*}
Quindi c'è la possibilità di inserirsi in un discorso in cui partecipano
pullback/pushout e kernel/cokernel.

\begin{proposition}\label{proposition:FromPullbackToKernel}
  In una categoria additiva \(\cat C\) il quadrato
  \[
    \begin{tikzcd}
      A \ar["{f}", r] \ar["{f'}", d, swap] & B \ar["{g}", d] \\
      C \ar["{g'}", r, swap] & D
    \end{tikzcd}
  \]
  è un quadrato di pullback se e solo se \((f, f') : A \to B \oplus C\)
  è kernel di \([g, -g'] : B \oplus C \to D\). Dualmente, lo stesso
  quadrato è di pushout se e solo se \([g, -g'] : B \oplus C \to D\) è
  cokernel di \((f, f') : A \to B \oplus C\).
\end{proposition}

\begin{proof}
  % \begin{itemize}
  % \item[(\(\Rightarrow\))]
  (\(\Rightarrow\)) In questo parte del lavoro è già fatto. Sia quindi
  \[
    \begin{tikzcd}
      E \ar["{h}", r] & B \oplus C \ar["{[g, -g']}", r, shift left]
      \ar["{0_{B \oplus C}^D}", r, shift right, swap] & D
    \end{tikzcd}
  \]
  commutativo. Abbiamo cioè \([g, -g'] h = g p_B h - g' p_C h = 0_E^D\),
  vale a dire commuta il quadrato esterno in
  \[
    \begin{tikzcd}
      E \ar["{p_B h}", drr, bend left] \ar["{p_C h}", ddr, swap,
      bend right] \\
      & {\color{gray} A} \ar["{f}" gray, gray, r, swap] \ar["{f'}" gray, gray, d] & B \ar["{g}", d] \\
      & C \ar["{g'}", r, swap] & D
    \end{tikzcd}
  \]
  Per la proprietà universale di pullback, esiste un unico
  \(k : E \to A\) per cui \(f k = p_B h\) e \(f' k = p_C h\). Rimane
  quindi da verificare che \((f, f') k = h\):
  \begin{align*}
    (f, f') k &= i_B \underbrace{f k}_{\crampedclap{=p_B h}} + i_C \underbrace{f' k}_{\crampedclap{=p_C h}} = \\
              &= \underbrace{(i_B p_B + i_C p_C)}_{\id_{B \oplus C}} h = h
  \end{align*}
  \(k\) è l'unico a fare ciò. Se \(k' : E \to A\) è tale che
  \((f, f') k' = h\), allora precomponendo una volta per \(p_B\) e
  un'altra per \(p_C\), abbiamo \(f k' = p_B h\) e \(f' k = p_C h'\). Ma
  questo, per la proprietà universale di pullback significa che
  \(k = k'\).\newline
  % \item[(\(\Leftarrow\))]
  (\(\Leftarrow\)) Verifichiamo anzitutto che il quadrato è
  commutativo. Poiché \((f, f')\) è kernel di \([g, -g']\), allora
  \([g, -g'] (f, f') = 0_A^D\), e questo è un conto che abbiamo già
  fatto. Prendiamo ora un qualsiasi quadrato commutativo
  \[
    \begin{tikzcd}
      E \ar["{s}", r] \ar["{s'}", d, swap] & B \ar["{g}", d] \\
      C \ar["{g'}", r, swap] & D
    \end{tikzcd}
  \]
  Come abbiamo visto, possiamo ottenere
  \([g, -g'] (r, r') = 0_E^D = 0_{B \oplus C}^D (h, h')\). Per la
  proprietà universale di equalizzatore, abbiamo che esiste uno e un
  solo \(s : E \to A\) tale che \((f, f') s = (r, r')\). Da qui, per
  concludere è sufficiente precomporre una volta con \(p_B\) e un'altra
  con \(p_C\). %\qedhere
  % \end{itemize}
\end{proof}


\subsection{Equalizzatori e coequalizzatori}

Parliamo ora di equalizzatori e coequalizzatori. Il discorso è piuttosto
semplice.

\begin{proposition}\label{proposition:EqualizersAreKernels}
  In una categoria preadditiva \(\cat C\) con oggetto zero \(0\), gli
  equalizzatori di
  \[
    \begin{tikzcd}
      A \ar["f", r, shift left] \ar["g", r, shift right, swap] & B
    \end{tikzcd}
  \]
  sono equalizzatori di
  \[
    \begin{tikzcd}
      A \ar["{f-g}", r, shift left] \ar["{0_A^B}", r, shift right, swap]
      & B
    \end{tikzcd}
  \]
  e viceversa. Analogamente vale per i coequalizzatori.
\end{proposition}

Quindi un (co)equalizzatore di una coppia di morfismi è un (co)kernel
della differenza dei due.

\begin{proof}
  Basta osservare che
  \[
    \begin{tikzcd}
      E \ar["i", r] & A \ar["f", r, shift left] \ar["g", r, shift right,
      swap] & B
    \end{tikzcd}
  \]
  commuta se e solo se commuta
  \[
    \begin{tikzcd}
      E \ar["i", r] & A \ar["{f-g}", r, shift left] \ar["{0_A^B}", r,
      shift right, swap] & B
    \end{tikzcd}
    \qedhere\]
\end{proof}



%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "../main"
%%% TeX-engine: luatex
%%% ispell-local-dictionary: "italian"
%%% End:
