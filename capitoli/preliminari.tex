
\chapter{Preliminari}

In queste note si assume almeno la {\sc Teoria delle Categorie} che si
può imparare da~\cite{leinster:categories}. Un altro validissimo testo è
anche~\cite{riehl:categories}. Un vero e proprio classico che contiene
anche nozioni sulle categorie preadditive è~\cite{maclane:categories}



\section{Kernel e cokernel}

Noi lavoreremo con categorie in cui sono presenti oggetti che sono sia
terminali che iniziali. Oggetti di questo tipo sono detti {\em oggetti
  zero}. Non si tratta di categorie come \(\Set\), \(\Top\) e
\(\Ring\), ma è il caso di \(\Grp\) e \(\Modu_R\), con \(R\) anello.

\begin{definition}
  Sia \(\cat C\) una categoria con {\em oggetto zero} che indichiamo
  con \(0\). Per \(a, b \in \obj{\cat C}\), il {\em morfismo nullo} o
  {\em zero} da \(a\) a \(b\) è la composizione dei morfismi
  \[
    \begin{tikzcd}[column sep=small]
      a \ar["{\exists!}", r] & 0 \ar["{\exists!}", r] & b
    \end{tikzcd}
  \]
  Scriveremo questo morfismo come \(0_a^b\) oppure, se dal contesto è
  chiaro, semplicemente \(0\).
\end{definition}

\begin{example}
  In casi come \(\Grp\) e \(\Modu_R\), il morfismo nullo è quello che
  manda tutti gli elementi del dominio nell'identità. Anche \(\Ring\)
  possiede omomorfismi come questi; tuttavia in \(\Ring\) l'oggetto
  iniziale è \(\mathbb{Z}\) che non è terminale mentre i morfismi zero sono
  definiti attraverso oggetti zero.
\end{example}

Comporre con un morfismo nullo dà un morfismo nullo. Più precisamente:

\begin{proposition}\label{lemma:CompCon0}
  Sia \(\cat C\) una categoria con {\em oggetto zero} \(0\), e
  \(a, b, c \in \obj{\cat C}\). Allora per ogni \(f : b \to c\) di
  \(\cat C\) si ha
  \[
    f \circ 0_a^b = 0_a^c
  \]
  e per ogni \(g : c \to a\) di \(\cat C\) si ha
  \[
    0_a^b \circ g = 0_c^b .
  \]
\end{proposition}

\begin{proof}
  Proviamo solo una delle due uguaglianze perché l'altra è
  simile. Consideriamo i morfismi
  \[
    \begin{tikzcd}[column sep=small]
      a \ar["{\exists!}", r] & 0 \ar["{\exists!}", r] & b \ar["f", r] & c
    \end{tikzcd}
  \]
  Poiché \(0\) è iniziale, la composizione delle ultime due frecce è
  l'unica che può esserci. Quindi \(f \circ 0_a^b\) è la composizione
  della freccia \(a \to 0\) con la freccia \(0 \to c\), ed abbiamo
  concluso.
\end{proof}

\begin{definition}[Kernel e cokernel]
  In una categoria \(\cat C\) con oggetto zero \(0\), il {\em kernel}
  di \(f : a \to b\) è uno qualsiasi degli equalizzatori di
  \[
    \begin{tikzcd}
      a \ar["f", shift left, r] \ar["{0_a^b}", shift right, swap, r] &
      b
    \end{tikzcd}
  \]
  Dualmente, il {\em cokernel} di \(f : a \to b\) è uno qualsiasi dei
  coequalizzatori della stessa coppia di morfismi.
\end{definition}

\begin{remark}
  Ricordiamo che in generale gli equalizzatori sono monomorfismi e i
  coequalizzatori sono epimorfismi. Questa informazione può dare delle
  indicazioni su come sono fatti i kernel e i cokernel in categorie in
  cui monomorfismo ed epimorfismo significano rispettivamente
  iniettivo e suriettivo.
\end{remark}

\begin{example}[Kernel di omomorfismi di moduli]\label{example:KernelInModR}
  In Algebra, si parla di {\em kernel} di morfismi in vari ambiti. Per
  esempio, se \(M\) e \(N\) sono due moduli su un fissato anello \(R\)
  e \(f : M \to N\) è un omomorfismo, allora
  \[
    \ker f := \set{x \in M \mid f(x) = 0_N}
  \]
  è un sottomodulo di \(M\). Per entrare nel linguaggio della {\sc
    Teoria delle Categorie},
  \begin{quotation}
    l'omomorfismo inclusione \(i : \ker f \hookrightarrow M\) è un equalizzatore
    della coppia di omomorfismi
    \[
      \begin{tikzcd}
        M \ar["f", shift left, r] \ar["{0_M^N}", shift right, swap, r]
        & N
      \end{tikzcd}
    \]
  \end{quotation}
  % Verifichiamo l'affermazione. Anzitutto, è facile vedere che
  % \(f \circ i = 0_M^N \circ i\), poiché per la
  % Proposizione~\ref{lemma:CompCon0} si ha che
  % \(0_M^N \circ i = 0_{\ker f}^N\). Consideriamo ora invece un qualsiasi
  % diagramma commutativo
  % \[
  %   \begin{tikzcd}
  %     E \ar["j", r] & M \ar["f", shift left, r] \ar["{0_M^N}", shift
  %     right, swap, r] & N
  %   \end{tikzcd}
  % \]
  % Questo implica che \(f(j(x)) = 0_M^N (j(x)) = 0_N\) per ogni
  % \(x \in E\). Questo significa che le immagini di \(j\) stanno in
  % \(\ker f\), quindi è possibile la fattorizzazione \(j = i \circ k\) dove
  % \(k : E \hookrightarrow \ker f\) è una semplice inclusione. Per finire
  % \(k\) è l'unico omomorfismo \(E \to \ker f\) per cui commuta il
  % triangolo
  % \[
  %   \begin{tikzcd}
  %     \ker f \ar["i", r] & M \\
  %     E \ar[u] \ar["j", ur, swap]
  %   \end{tikzcd}
  % \]
  % a causa dell'iniettività di \(i\).
\end{example}

\begin{example}[Cokernel di omomorfismi di moduli]\label{example:CokernelInModR}
  Se \(M\) e \(N\) sono due moduli su un fissato anello \(R\) e
  \(f : M \to N\) è un omomorfismo, allora
  \[
    \coker f := \frac{N}{\im f}
  \]
  è un sottomodulo di \(M\) chiamato {\em cokernel} di \(f\). Questa
  nozione è il duale di kernel, nel senso che
  \begin{quotation}
    l'omomorfismo di proiezione canonica al quoziente
    \(\pi_N : N \to \coker f\) è un coequalizzatore della coppia di
    omomorfismi
    \[
      \begin{tikzcd}
        M \ar["f", shift left, r] \ar["{0_M^N}", shift right, swap, r]
        & N
      \end{tikzcd}
    \]
  \end{quotation}
  % Per dimostrare questo fatto si può usare un teorema di omomorfismo,
  % oppure un argomento categoriale come questo.
  % \begin{enumerate}
  % \item Considerare il funtore dimenticante \(U : \Modu_R \to \Set\) che
  %   è fedele.
  % \item In \(\Set\) un coequalizzatore di
  %   \[
  %     \begin{tikzcd}
  %       X \ar["f", r, shift left] \ar["g", r, shift right, swap] & Y
  %     \end{tikzcd}
  %   \]
  %   è la proiezione canonica al quoziente \(p : Y \to Y{/}\sim\) dove
  %   \(\sim\) è la relazione di equivalenza generata da
  %   \(f(a) \sim f(b)\) al variare di \(a, b \in X\).
  % \item Se \(M\) è un modulo su \(R\) e \(H\) è un suo sottomodulo, il
  %   modulo quoziente \(\frac{M}{H}\) è ottenuto quozientando \(M\) con
  %   la relazione di equivalenza \(\sim\) generata da \(x+h \sim x\) per
  %   \(x \in M, h \in H\).
  % \end{enumerate}
\end{example}

\begin{remark}
  In Algebra, kernel e cokernel sono degli oggetti, mentre
  tecnicamente come sono definiti qui sono dei morfismi.
\end{remark}



\section{Categorie preadditive}

\begin{definition}
  Una {\em categoria preadditiva} è una categoria \(\cat C\) in cui:
  \begin{enumerate}[leftmargin=*]
  \item Per ogni \(a, b \in \obj{\cat C}\) la classe \(\cat C(a, b)\) è
    dotata di un'operazione interna
    \[
      +_{a,b} : \cat C (a, b) \times \cat C (a, b) \to \cat C (a, b)
    \]
    e ha un elemento \(0_a^b : a \to b\) che lo rendono un gruppo
    abeliano.
  \item Per ogni \(a, b, c \in \obj{\cat C}\) e \(f : a \to b\) di
    \(\cat C\), le funzioni
    \begin{align*}
      & f_\ast := \cat C(c, f) : \cat C(c, a) \to \cat C(c, b) \\
      & f^\ast := \cat C(f, c) : \cat C(b, c) \to \cat C(a, c)
    \end{align*}
    sono omomorfismi di gruppi abeliani.
  \end{enumerate}
\end{definition}

\begin{recall}
  Ricordiamo che \(f_\ast(g) := f \circ g\) mentre \(f^\ast(h) := h \circ f\).
\end{recall}

Spesso scriveremo semplicemente \(+\) senza pedici, perché in genere è
chiaro di quali frecce stiamo sommando.

Inoltre, come nei primi teoremi di Algebra, il morfismo zero è l'unico
elemento neutro e per ogni \(f : a \to b\) è unico l'opposto. In
coerenza con la notazione additiva indichiamo con \(- f\) l'opposto di
\(f : a \to b\).

Un'altra osservazione da fare è questa. Il simbolo \(0_a^b\) in una
categoria \(\cat C\) con oggetto zero indica il morfismo zero
\(a \to b\). Se \(\cat C\) è preaddittiva, non sono notazioni in
conflitto?  No.

\begin{proposition}
  In una categoria preadditiva \(\cat C\) con oggetto zero \(0\), il
  morfismo nullo è elemento neutro.
\end{proposition}

\begin{proof}
  Poiché \(0\) è iniziale, \(\cat C(0, b)\) è banale e in particolare
  \(0_0^b\) è elemento neutro. L'omomorfismo
  \[
    \left(0_a^0\right)^\ast : \cat C(0, b) \to \cat C(a, b)
  \]
  manda l'elemento neutro del dominio in quello del codominio, che è
  \[
    \left(0_a^0\right)^\ast\left(0_0^b\right) = 0_0^b \circ 0_a^0 = 0_a^b
    . \qedhere
  \]
\end{proof}

\begin{remark}
  A tal proposito è utile osservare che se \(\cat C\) è una categoria
  preadditiva, anche il suo duale \(\opcat C\) lo è. La conseguenza più
  pratica per noi è che dimezza le dimostrazioni: una volta dimostrato
  un enunciato, quello duale è automatico.
\end{remark}



\section{Limiti e limiti}

Ora parleremo di alcune peculiarità dei limiti e dei colimiti in
categorie preadditive.


\subsection{Oggetti iniziali e terminali}

\begin{proposition}
  In un categoria preadditiva \(\cat C\) gli oggetti terminali sono
  iniziali e viceversa.
\end{proposition}

Quindi in una categoria preadditiva gli oggetti terminali e iniziali
sono oggetti zero.

\begin{proof}
  Sia \(t\) un oggetto terminale di \(\cat C\). Se riusciamo a
  mostrare che \(\cat C(t, a)\) è un gruppo banale per ogni oggetto
  \(a\) di \(\cat C\), allora possiamo concludere.\newline Prendiamo un
  \(f : t \to a\) qualsiasi in \(\cat C\) e guardiamo l'omomorfismo di
  gruppi
  \[
    f_\ast = \cat C(t, f) : \cat C(t, t) \to \cat C(t, a) .
  \]
  Il dominio è un gruppo banale perché \(t\) è terminale; in
  particolare, \(\id_t = 0_t^t\). Inoltre, trattandosi di omomorfismo,
  \[
    \underbrace{f_\ast \left(\id_t\right)}_{= f} = f \circ 0_t^t = 0_t^a
    . \qedhere
  \]
\end{proof}


\subsection{Prodotti e coprodotti}

Vediamo i prodotti e i coprodotti finiti ora.

A proposito di notazioni, seguiamo~\cite{leinster:categories}
e~\cite{riehl:categories}. Più precisamente, preso un prodotto
\[
  \begin{tikzcd}[column sep=small]
    a & a \times b \ar["{p_a}", l, swap] \ar["{p_b}", r] & b
  \end{tikzcd}
\]
il morfismo \(c \to a \times b\) che fa commutare il diagramma
\[
  \begin{tikzcd}
    & c \ar["{f}", dl, swap] \ar[d] \ar["{g}", dr] \\
    a & a \times b \ar["{p_a}", l] \ar["{p_b}", r, swap] & b
  \end{tikzcd}
\]
è indicato con \((f, g)\); invece, dato un coprodotto
\[
  \begin{tikzcd}[column sep=small]
    a \ar["{i_a}", r] & a + b & b \ar["{i_b}", l, swap]
  \end{tikzcd}
\]
il morfismo \(a+b \to c\) rendo commutativo
\[
  \begin{tikzcd}
    & a \\
    a \ar["{i_a}", r, swap] \ar["{f}", ur] & a + b \ar[u] & b
    \ar["{i_b}", l] \ar["{g}", ul, swap]
  \end{tikzcd}
\]
è indicato con \([f, g]\).

Più in là avremo modo di introdurre una notazione ``matriciale'', che è
quella che usa~\cite{buehler:exactcategories} e consente di fare alcuni
conti molto più facilmente.

\begin{proposition}\label{proposition:BinProdsAreBinCoprods}
  Sia \(\cat C\) una categoria preadditiva con oggetto zero \(0\) e
  \[
    \begin{tikzcd}[column sep=small]
      a & a \times b \ar["{p_a}", l, swap] \ar["{p_b}", r] & b
    \end{tikzcd}
  \]
  un prodotto in \(\cat C\).  Introduciamo anche le frecce
  \begin{equation}
    \label{eq:InjViaProj}
    \begin{aligned}
      & i_a := \left( \id_a, 0_a^b \right) : a \to a \times b \\
      & i_b := \left( 0_b^a, \id_b \right) : b \to a \times b
    \end{aligned}
  \end{equation}
  Allora
  \[
    \begin{tikzcd}[column sep=small]
      a \ar["{i_a}", r] & a \times b & b \ar["{i_b}", l, swap]
    \end{tikzcd}
  \]
  è coprodotto in \(\cat C\). Dualmente, se
  \[
    \begin{tikzcd}[column sep=small]
      a \ar["{i_a}", r] & a + b & b \ar["{i_b}", l, swap]
    \end{tikzcd}
  \]
  è un coprodotto e se introduciamo anche i morfismi
  \begin{equation}
    \label{eq:ProjViaInj}
    \begin{aligned}
      & p_a := \left[ \id_a, 0_b^a \right] : a + b \to a \\
      & p_b := \left[ 0_a^b, \id_b \right] : a + b \to b
    \end{aligned}
  \end{equation}
  allora
  \[
    \begin{tikzcd}[column sep=small]
      a & a + b \ar["{p_a}", l, swap] \ar["{p_b}", r] & b
    \end{tikzcd}
  \]
  è un prodotto in \(\cat C\).
\end{proposition}

In breve: in categorie preadditive si ha \(a \times b \cong a+b\).

\begin{proof}
  Possiamo limitarci a dimostrare solo il primo fatto. Consideriamo un
  qualsiasi oggetto con morfismi
  \[
    \begin{tikzcd}[column sep=small]
      a \ar["f", r] & c & b \ar["g", l, swap]
    \end{tikzcd}
  \]
  e cerchiamo un modo di costruire un morfismo \(a \times b \to c\). Le
  frecce \(f \circ p_a\) e \(g \circ p_b\) sono di questo tipo, ma non vanno
  bene per i nostri scopi. Invece la somma sì, perché il diagramma
  \[
    \begin{tikzcd}[row sep=large]
      & c \\
      a \ar["{i_a}", r, swap] \ar["f", ur, bend left] & a + b \ar["{f \circ p_a + g \circ
        p_b}" description, u] & b
      \ar["{i_b}", l] \ar["g", ul, bend right, swap]
    \end{tikzcd}
  \]
  commuta.
\end{proof}

\begin{definition}\label{definition:Biprodotto}
  Un {\em biprodotto} in una categoria preadditiva consta di oggetti e frecce
  \[
    \begin{tikzcd}
      a \ar["{i_a}", r, shift right, swap] & c \ar["{p_a}", l, shift
      right, swap] \ar["{p_b}", r, shift left] & b \ar["{i_b}", l,
      shift left]
    \end{tikzcd}
  \]
  tali che
  \begin{align}
    & p_a \circ i_a = \id_a \label{eqn:Biprod1} \\
    & p_b \circ i_b = \id_b \label{eqn:Biprod2}\\
    & i_a \circ p_a + i_b \circ p_b = \id_c \label{eqn:Biprod3}
  \end{align}
\end{definition}

\begin{remark}
  Dalle identità~\ref{eqn:Biprod1}, \ref{eqn:Biprod2}
  e~\ref{eqn:Biprod3} discendono
  \begin{align}
    & p_a \circ i_b = 0_b^a \label{eqn:Biprod4} \\
    & p_b \circ i_a = 0_a^b \label{eqn:Biprod5}
  \end{align}
  Proviamo solo la prima visto che l'altra si fa similmente.
  \[
    p_a \underbrace{=}_{\mathclap{\eqref{eqn:Biprod3}}} p_a \circ \left(
      i_a \circ p_a + i_b \circ p_b \right)
    \underbrace{=}_{\mathclap{\eqref{eqn:Biprod1}}} p_a + p_a \circ i_b
    \circ p_b
  \]
  da cui
  \[
    p_a \circ i_b \circ p_b = 0_c^a .
  \]
  Postcomponendo con \(i_b\) e usando~\eqref{eqn:Biprod2}, concludiamo
  \(p_a \circ i_b = 0_b^a\).
\end{remark}

Un'altra proprietà utile per il futuro è questa.

\begin{proposition}
  I morfismi \(i_a\) e \(i_b\) della
  Definizione~\ref{definition:Biprodotto} sono monici. I morfismi
  \(p_a\) e \(p_b\) invece sono epici.
\end{proposition}

\begin{proof}
  Ad esempio, sia \(i_a \circ f = i_a \circ g\). Precomponendo ambo i
  mebri con \(p_a\), a causa di~\eqref{eqn:Biprod1}, si ha \(f =
  g\). Sia ora \(k \circ p_a = h \circ p_a\). Postcomponendo ambi membri
  per \(i_a\), sempre a causa di~\eqref{eqn:Biprod1}, si arriva a
  \(h = k\).
\end{proof}

I biprodotti sono prodotti e coprodotti binari.

\begin{proposition}\label{proposition:BiprodsAreProdsAndCoprods}
  In una categoria preadditiva con oggetto zero \(0\) consideriamo il
  biprodotto
  \[
    \begin{tikzcd}
      a \ar["{i_a}", r, shift right, swap] & c \ar["{p_a}", l, shift
      right, swap] \ar["{p_b}", r, shift left] & b \ar["{i_b}", l, shift
      left]
    \end{tikzcd}
  \]
  allora la coppia di frecce \(p_a\) e \(p_b\) è prodotto e la coppia
  \(i_a\) e \(i_b\) è coprodotto.  In particolare, presi
  \(d \in \obj{\cat C}\) e una coppia di frecce
  uscenti \begin{tikzcd}[cramped, column sep=small] a & c \ar["{f}", l,
    swap] \ar["{g}", r] & b
  \end{tikzcd},
  \[
    (f, g) = i_a \circ f + i_b \circ g .
  \]
  Invece presi \(e \in \obj{\cat C}\) e una coppia di
  morfismi \begin{tikzcd}[cramped, column sep=small] a \ar["{h}", r] & c
    & b \ar["{k}", l, swap]
  \end{tikzcd},
  \[ [h, k] = h \circ p_a + k \circ p_b .
  \]
  Infine, notare anche che \(c \cong a \times b \cong a + b\).
\end{proposition}

\begin{proof}
  Facciamo solo la parte che riguarda il prodotto, perché l'altra si fa
  con un ragionamento non tanto diverso. Grazie a~\eqref{eqn:Biprod1}
  e~\eqref{eqn:Biprod4} abbiamo
  \begin{align*}
    & p_a \circ \left( i_a \circ f + i_b \circ g \right) = f \\
    & p_b \circ \left( i_a \circ f + i_b \circ g \right) = g
  \end{align*}
  Ora se \(h : d \to c\) è tale che \(p_a \circ h = f\) e
  \(p_b \circ h = g\), allora
  \[
    h = \id_{c} \circ h \underbrace{=}_{\mathclap{\eqref{eqn:Biprod3}}}
    \left( i_a \circ p_a + i_b \circ p_b \right) \circ h = i_a \circ f +
    i_b \circ g .
  \]
  Possiamo quindi concludere che le frecce \(p_a\) e \(p_b\) formano un
  prodotto.
\end{proof}

Vale anche il viceversa.

\begin{proposition}\label{proposition:ProdsAndCoprodsAreBiprods}
  In una categoria preadditiva con oggetto zero \(0\), un prodotto
  \[
    \begin{tikzcd}[column sep=small]
      a & a \times b \ar["{p_a}", l, swap] \ar["{p_b}", r] & b
    \end{tikzcd}
  \]
  dà un biprodotto
  \[
    \begin{tikzcd}
      a \ar["{i_a}", r, shift right, swap] & a \times b \ar["{p_a}", l,
      shift right, swap] \ar["{p_b}", r, shift left] & b \ar["{i_b}", l,
      shift left]
    \end{tikzcd}
  \]
  in cui \(i_a\) e \(i_b\) sono introdotti come
  in~\eqref{eq:InjViaProj}. Dualmente, un coprodotto
  \[
    \begin{tikzcd}[column sep=small]
      a \ar["{i_a}", r] & a + b & b \ar["{i_b}", l, swap]
    \end{tikzcd}
  \]
  dà un biprodotto
  \[
    \begin{tikzcd}
      a \ar["{i_a}", r, shift right, swap] & a+b \ar["{p_a}", l, shift
      right, swap] \ar["{p_b}", r, shift left] & b \ar["{i_b}", l, shift
      left]
    \end{tikzcd}
  \]
  in cui \(p_a\) e \(p_b\) sono introdotti come
  in~\eqref{eq:ProjViaInj}.
\end{proposition}

\begin{proof}
  Questa è una prosecuzione della dimostrazione della
  Proposizione~\ref{proposition:BinProdsAreBinCoprods}. Verifichiamo ad
  esempio che i prodotti danno biprodotti. Le
  identità~\eqref{eqn:Biprod1}, \eqref{eqn:Biprod2}, \eqref{eqn:Biprod4}
  e~\eqref{eqn:Biprod5} discendono direttamente da come sono introdotte
  \(i_a\) e \(i_b\). Consideriamo ora il morfismo
  \[
    i_a \circ p_a + i_b \circ p_b : a \times b \to a \times b .
  \]
  Componendo una volta con \(p_a\) e l'altra con \(p_b\) si ha
  \begin{align*}
    & p_a \circ \left(i_a \circ p_a + i_b \circ p_b\right) = \underbrace{p_a \circ
      i_a}_{= \id_a} \circ p_a + \underbrace{p_a
      \circ i_b}_{= 0_b^a} \circ p_b = p_a \\
    & p_b \circ \left(i_a \circ p_a + i_b \circ p_b\right) = \underbrace{p_b \circ
      i_a}_{= 0_a^b} \circ p_a + \underbrace{p_b
      \circ i_b}_{= \id_b} \circ p_b = p_b
  \end{align*}
  Per la proprietà universale di prodotto, si può concludere che
  \[
    i_a \circ p_a + i_b \circ p_b = \id_{a \times b} . \qedhere
  \]
\end{proof}

La morale della storia è che in categorie preadditive esiste un modo
piuttosto compatto di esprimere prodotti e coprodotti (che sono la
stessa cosa) senza passare per le proprietà universali. E poiché
\(a \times b \cong a + b\), si decide di indicare uno qualsiasi di
questi oggetti con \(a \oplus b\).

\begin{definition}
  Una {\em categoria additiva} è una categoria che ha oggetto zero e che
  per ogni coppia di oggetti \(a\) e \(b\) possiede biprodotto
  \[
    \begin{tikzcd}
      a \ar["{i_a^{ab}}", r, shift right, swap] & a \oplus b
      \ar["{p_a^{ab}}", l, shift right, swap] \ar["{p_b^{ab}}", r, shift
      left] & b \ar["{i_b^{ab}}", l, shift left]
    \end{tikzcd}
  \]
\end{definition}

Spesso è ovvio dal contesto e quindi scriveremo semplicemente \(p_a\) al
posto di \(p_a^{ab}\) e così via.

Vedendo \(a \oplus b\) come \(a \times b\), presi due morfismi
\(f : a \to b\) e \(g : c \to d\), definiamo
\(f \oplus g : a \oplus c \to b \oplus d\) come \(f \times g\), cioè
come l'unica freccia \(a \oplus c \to b \oplus d\) che fa commutare
\[
  \begin{tikzcd}
    a \ar["{f}", d, swap] & a \oplus c \ar["{p_a^{ac}}", l, swap]
    \ar["{}", d] \ar["{p_c^{ac}}", r] & c \ar["{g}", d] \\
    b & b \oplus d \ar["{p_b^{bd}}", l] \ar["{p_d^{bd}}", r, swap] & d
  \end{tikzcd}
\]
Sfruttando questa volta la proprietà universale di coprodotto, vedendo
\(a \oplus b\) come \(a + b\), si può definire \(f \oplus g\) come
\(f + g\).


\subsection{Pullback e pushout}

Parliamo dei pullback e dei pushout ora. Sia \(\cat C\) una categoria
additiva e consideriamo in essa il quadrato commutativo
\[
  \begin{tikzcd}
    a \ar["{f}", r] \ar["{f'}", d, swap] & b \ar["{g}", d] \\
    c \ar["{g'}", r, swap] & d
  \end{tikzcd}
\]
e ``schiacciamo'' il tutto in questo modo
\[
  \begin{tikzcd}
    a \ar["{(f, f')}", r] & b \oplus c \ar["{[g, -g']}", r] & d
  \end{tikzcd}
\]
Il motivo per cui è \([g, -g']\) e non \([g, g']\) viene spiegato
subito. Grazie alla
Proposizione~\ref{proposition:BiprodsAreProdsAndCoprods}, abbiamo
un'espressione esplicita per \((f,f')\) e \([g,-g']\) e quindi:
\begin{align*} [g, -g'] \circ (f, f') &= (g \circ p_b + (-g') \circ p_c)
  \circ (i_b
                                        \circ f + i_c \circ f') = \\
                                      &= g \circ f - g' \circ f' = 0_a^d
                                        .
\end{align*}
Quindi c'è la possibilità di inserirsi in un discorso in cui partecipano
pullback/pushout e kernel/cokernel.

\begin{proposition}\label{proposition:FromPullbackToKernel}
  In una categoria additiva \(\cat C\) il quadrato
  \[
    \begin{tikzcd}
      a \ar["{f}", r] \ar["{f'}", d, swap] & b \ar["{g}", d] \\
      c \ar["{g'}", r, swap] & d
    \end{tikzcd}
  \]
  è di pullback se e solo se \((f, f') : a \to b \oplus c\) è kernel di
  \([g, -g'] : b \oplus c \to d\).
\end{proposition}

\begin{proof}
  % \begin{itemize}
  % \item[(\(\Rightarrow\))]
  (\(\Rightarrow\)) In questo parte del lavoro è già fatto. Sia quindi
  \[
    \begin{tikzcd}
      e \ar["{h}", r] & b \oplus c \ar["{[g, -g']}", r, shift left]
      \ar["{0_{b \oplus c}^d}", r, shift right, swap] & d
    \end{tikzcd}
  \]
  commutativo. Abbiamo cioè
  \([g, -g'] \circ h = g \circ p_b \circ h - g' \circ p_c \circ h =
  0_e^d\), vale a dire commuta il quadrato esterno in
  \[
    \begin{tikzcd}
      e \ar["{p_b \circ h}", drr, bend left] \ar["{p_c \circ h}", ddr,
      swap,
      bend right] \\
      & {\color{gray} a} \ar["{f}" gray, gray, r, swap] \ar["{f'}" gray, gray, d] & b \ar["{g}", d] \\
      & c \ar["{g'}", r, swap] & d
    \end{tikzcd}
  \]
  Per la proprietà universale di pullback, esiste un unico
  \(k : e \to a\) per cui \(f \circ k = p_b \circ h\) e
  \(f' \circ k = p_c \circ h\). Rimane quindi da verificare che
  \((f, f') \circ k = h\):
  \begin{align*}
    (f, f') \circ k &= i_b \circ \underbrace{f \circ
                      k}_{\crampedclap{=p_b \circ h}} + i_c \circ \underbrace{f'
                      \circ k}_{\crampedclap{=p_c \circ h}} = \\
                    &= \underbrace{(i_b \circ p_b + i_c \circ
                      p_c)}_{\id_{b \oplus c}} \circ h = h
  \end{align*}
  \(k\) è l'unico a fare ciò. Se \(k' : e \to a\) è tale che
  \((f, f') \circ k' = h\), allora precomponendo una volta per \(p_b\) e
  un'altra per \(p_c\), abbiamo \(f \circ k' = p_b \circ h\) e
  \(f' \circ k = p_c \circ h'\). Ma questo, per la proprietà universale
  di pullback significa che \(k = k'\).\newline
  % \item[(\(\Leftarrow\))]
  (\(\Leftarrow\)) Verifichiamo anzitutto che il quadrato è
  commutativo. Poiché \((f, f')\) è kernel di \([g, -g']\), allora
  \([g, -g'] \circ (f, f') = 0_a^d\), e questo è un conto che abbiamo
  già fatto. Prendiamo ora un qualsiasi quadrato commutativo
  \[
    \begin{tikzcd}
      e \ar["{s}", r] \ar["{s'}", d, swap] & b \ar["{g}", d] \\
      c \ar["{g'}", r, swap] & d
    \end{tikzcd}
  \]
  Come abbiamo visto sopra, possiamo ottenere
  \([g, -g'] \circ (r, r') = 0_e^d = 0_{b \oplus c}^d \circ (h,
  h')\). Per la proprietà universale di equalizzatore, abbiamo che
  esiste uno e un solo \(s : e \to a\) tale che
  \((f, f') \circ s = (r, r')\). Da qui, per concludere è sufficiente
  precomporre una volta con \(p_b\) e un'altra con \(p_c\). %\qedhere
  % \end{itemize}
\end{proof}


\subsection{Equalizzatori e coequalizzatori}

Parliamo ora di equalizzatori e coequalizzatori. Il discorso è piuttosto
semplice.

\begin{proposition}
  In una categoria preadditiva \(\cat C\) con oggetto zero \(0\), gli
  equalizzatori di
  \[
    \begin{tikzcd}
      a \ar["f", r, shift left] \ar["g", r, shift right, swap] & b
    \end{tikzcd}
  \]
  sono equalizzatori di
  \[
    \begin{tikzcd}
      a \ar["{f-g}", r, shift left] \ar["{0_a^b}", r, shift right, swap]
      & b
    \end{tikzcd}
  \]
  e viceversa. Analogamente vale per i coequalizzatori.
\end{proposition}

Quindi un (co)equalizzatore di una coppia di morfismi è un (co)kernel
della differenza dei due.

\begin{proof}
  Basta osservare che
  \[
    \begin{tikzcd}
      e \ar["i", r] & a \ar["f", r, shift left] \ar["g", r, shift right,
      swap] & b
    \end{tikzcd}
  \]
  commuta se e solo se commuta
  \[
    \begin{tikzcd}
      e \ar["i", r] & a \ar["{f-g}", r, shift left] \ar["{0_a^b}", r,
      shift right, swap] & b
    \end{tikzcd}
    \qedhere\]
\end{proof}



%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "../main"
%%% TeX-engine: luatex
%%% ispell-local-dictionary: "italian"
%%% End:
